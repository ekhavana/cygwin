<title>The Cygwin Project FAQ 20.2 for Release B20.1.  - Programming Questions</title>
Go to the <A HREF="faq_1.html">first</A>, <A HREF="faq_8.html">previous</A>, <A HREF="faq_10.html">next</A>, <A HREF="faq_13.html">last</A> section, <A HREF="faq_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC67" HREF="faq_toc.html#TOC67">Programming Questions</A></H1>



<H2><A NAME="SEC68" HREF="faq_toc.html#TOC68">Why is gcc failing?</A></H2>

<P>
If the error is "gcc: installation problem, cannot exec `cpp':
No such file or directory", the GCC_EXEC_PREFIX environment variable
hasn't been set correctly.  The current release does not need
GCC_EXEC_PREFIX set -- it should be able to find cpp regardless of the
install location.  But if you have it set incorrectly, you may still
see this message.

</P>


<H2><A NAME="SEC69" HREF="faq_toc.html#TOC69">Why can't bison find bison.simple or bison.hairy?</A></H2>

<P>
If you are getting a warning to this effect, you need to set
the BISONLIB environment variable.  The value should be the directory
in which bison.simple and bison.hairy are installed.  This will be
the path leading up to and including the <CODE>share</CODE> directory of
the top-level of the binary distributions.  For example, on some
systems, you would want to set it to <CODE>C:/cygnus/cygwin-b20/share</CODE>.

</P>


<H2><A NAME="SEC70" HREF="faq_toc.html#TOC70">Why is make behaving badly?</A></H2>

<P>
Starting with the beta 19 release, make defaults to a win32 mode in
which backslashes in filenames are permitted and cmd.exe/command.com
is used as the sub-shell.  In this mode, escape characters aren't
allowed among other restrictions.  For this reason, you must set
the environment variable MAKE_MODE to UNIX to run make on ordinary Unix
Makefiles.  Here is the full scoop:

</P>
<P>
MAKE_MODE selects between native Win32 make mode (the default) and
a Unix mode where it behaves like a Unix make.  The Unix mode does
allow specifying Win32-style paths but only containing forward slashes
as the path separator.  The path list separator character is a colon
in Unix mode.

</P>
<P>
Win32 mode expects path separators to be either / or \.  Thus no
Unix-style \s as escape are allowed.  Win32 mode also uses
cmd.exe/command.com as the subshell which means "copy" and "del"
(and other shell builtins) will work.  The path list separator
character is semi-colon in Win32 mode.  People who want an nmake-like
make might want to use this mode but no one should expect Unix
Makefiles to compile in this mode.  That is why the default b19
install sets MAKE_MODE to UNIX.

</P>


<H2><A NAME="SEC71" HREF="faq_toc.html#TOC71">Why the undefined reference to "WinMain@16"?</A></H2>

<P>
Try adding an empty main() function to one of your sources.

</P>


<H2><A NAME="SEC72" HREF="faq_toc.html#TOC72">How do I use Win32 API calls?</A></H2>

<P>
It's pretty simple actually.  Cygwin tools require that you explicitly
link the import libraries for whatever Win32 API functions that you
are going to use, with the exception of kernel32, which is linked
automatically (because the startup and/or built-in code uses it).

</P>
<P>
For example, to use graphics functions (GDI) you must link
with gdi32 like this:

</P>
<P>
gcc -o foo.exe foo.o bar.o -lgdi32

</P>
<P>
or (compiling and linking in one step):

</P>
<P>
gcc -o foo.exe foo.c bar.c -lgdi32

</P>
<P>
The following libraries are available for use in this way:

</P>
<P>
advapi32  largeint  ole32     scrnsave  vfw32
cap       lz32      oleaut32  shell32   win32spl
comctl32  mapi32    oledlg    snmp      winmm
comdlg32  mfcuia32  olepro32  svrapi    winserve
ctl3d32   mgmtapi   opengl32  tapi32    winspool
dlcapi    mpr       penwin32  th32      winstrm
gdi32     msacm32   pkpd32    thunk32   wow32
glaux     nddeapi   rasapi32  url       wsock32
glu32     netapi32  rpcdce4   user32    wst
icmp      odbc32    rpcndr    uuid
imm32     odbccp32  rpcns4    vdmdbg
kernel32  oldnames  rpcrt4    version

</P>
<P>
The regular setup allows you to use the option -mwindows on the
command line to include a set of the basic libraries (and also
make your program a GUI program instead of a console program),
including user32, gdi32 and, IIRC, comdlg32.

</P>
<P>
Note that you should never include -lkernel32 on your link line
unless you are invoking ld directly.  Do not include the same import
library twice on your link line.  Finally, it is a good idea to
put import libraries last on your link line, or at least after
all the object files and static libraries that reference them.

</P>
<P>
The first two are related to problems the linker has (as of b18 at least)
when import libraries are referenced twice.  Tables get messed up and
programs crash randomly.  The last point has to do with the fact that
gcc processes the files listed on the command line in sequence and
will only resolve references to libraries if they are given after
the file that makes the reference.

</P>


<H2><A NAME="SEC73" HREF="faq_toc.html#TOC73">How do I compile a Win32 executable that doesn't use Cygwin?</A></H2>

<P>
The -mno-cygwin flag to gcc makes gcc link against standard Microsoft
DLLs instead of Cygwin.  This is desirable for native Windows programs
that don't need a UNIX emulation layer.

</P>


<H2><A NAME="SEC74" HREF="faq_toc.html#TOC74">How do I make the console window go away?</A></H2>

<P>
The default during compilation is to produce a console application.
It you are writing a GUI program, you should either compile with
-mwindows as explained above, or add the string
"-Wl,--subsystem,windows" to the GCC commandline.

</P>


<H2><A NAME="SEC75" HREF="faq_toc.html#TOC75">Why does make complain about a "missing separator"?</A></H2>

<P>
This problem usually occurs as a result of someone editing a Makefile
with a text editor that replaces tab characters with spaces.  Command
lines must start with tabs.

</P>


<H2><A NAME="SEC76" HREF="faq_toc.html#TOC76">Why can't we redistribute Microsoft's Win32 headers?</A></H2>

<P>
Subsection 2.d.f of the `Microsoft Open Tools License agreement' looks like
it says that can not "permit further redistribution of the
Redistributables to their end users".  We take this to mean that we can
give them to you, but you can't give them to anyone else, which is
something that Cygnus can't agree to.  Fortunately, we have our own
Win32 headers which are pretty complete.

</P>


<H2><A NAME="SEC77" HREF="faq_toc.html#TOC77">How do I link against .lib files?</A></H2>

<P>
1. Build a C file with a function table.  Put all functions you intend
to use in that table.  This forces the linker to include all the object
files from the .lib.  Maybe there is an option to force LINK.EXE to
include an object file.
2. Build a dummy 'LibMain'.
3. Build a .def with all the exports you need.
4. Link with your .lib using link.exe.

</P>
<P>
or

</P>
<P>
1. Extract all the object files from the .lib using LIB.EXE.
2. Build a dummy C file referencing all the functions you need, either
with a direct call or through an initialized function pointer.
3. Build a dummy LibMain.
4. Link all the objects with this file+LibMain.
5. Write a .def.
6. Link.

</P>
<P>
You can use these methods to use MSVC (and many other runtime libs)
with Cygwin development tools.

</P>
<P>
Note that this is a lot of work (half a day or so), but much less than
rewriting the runtime library in question from specs...

</P>
<P>
(thanks to Jacob Navia (root@jacob.remcomp.fr) for this explanation)

</P>


<H2><A NAME="SEC78" HREF="faq_toc.html#TOC78">How do I rebuild the tools on my NT box?</A></H2>

<P>
Assuming that you have the src installed as /src, will build in
the directory /obj, and want to install the tools in /install:

</P>

<PRE>
bash
cd /obj
/src/configure --prefix=/install -v &#62; configure.log 2&#62;&#38;1
make &#62; make.log 2&#62;&#38;1
make install &#62; install.log 2&#62;&#38;1
</PRE>



<H2><A NAME="SEC79" HREF="faq_toc.html#TOC79">How can I compile a powerpc NT toolchain?</A></H2>

<P>
Unfortunately, this will be difficult.  It hasn't been built for
some time (late 1996) since Microsoft has dropped development of
powerpc NT.  Exception handling/signals support semantics/args have been
changed for x86 and not updated for ppc so the ppc specific support would
have to be rewritten.  We don't know of any other incompatibilities.
Please send us patches if you do this work!

</P>


<H2><A NAME="SEC80" HREF="faq_toc.html#TOC80">How can I compile an Alpha NT toolchain?</A></H2>

<P>
We have not ported the tools to Alpha NT and do not have plans to
do so at the present time.  We would be happy to add support
for Alpha NT if someone contributes the changes to us.

</P>


<H2><A NAME="SEC81" HREF="faq_toc.html#TOC81">How can I adjust the heap/stack size of an application?</A></H2>

<P>
Pass heap/stack linker arguments to gcc.  To create foo.exe with
a heap size of 1024 and a stack size of 4096, you would invoke
gcc as:

</P>
<P>
<CODE>gcc -Wl,--heap,1024,--stack,4096 -o foo foo.c</CODE>

</P>


<H2><A NAME="SEC82" HREF="faq_toc.html#TOC82">How can I find out which dlls are needed by an executable?</A></H2>

<P>
objdump -p provides this information.

</P>


<H2><A NAME="SEC83" HREF="faq_toc.html#TOC83">How do I build a DLL?</A></H2>

<P>
There's documentation that explains the process on the main Cygwin
project web page (http://sourceware.cygnus.com/cygwin/).

</P>


<H2><A NAME="SEC84" HREF="faq_toc.html#TOC84">How can I set a breakpoint at MainCRTStartup?</A></H2>

<P>
Set a breakpoint at *0x401000 in gdb and then run the program in
question.

</P>


<H2><A NAME="SEC85" HREF="faq_toc.html#TOC85">How can I build a relocatable dll?</A></H2>

<P>
You must execute the following sequence of five commands, in this
order:

</P>

<PRE>
$(LD) -s --base-file BASEFILE --dll -o DLLNAME OBJS LIBS -e ENTRY

$(DLLTOOL) --as=$(AS) --dllname DLLNAME --def DEFFILE \
        --base-file BASEFILE --output-exp EXPFILE

$(LD) -s --base-file BASEFILE EXPFILE -dll -o DLLNAME OBJS LIBS -e ENTRY

$(DLLTOOL) --as=$(AS) --dllname DLLNAME --def DEFFILE \
	--base-file BASEFILE --output-exp EXPFILE

$(LD) EXPFILE --dll -o DLLNAME OBJS LIBS -e ENTRY
</PRE>

<P>
In this example, $(LD) is the linker, ld.

</P>
<P>
$(DLLTOOL) is dlltool.

</P>
<P>
$(AS) is the assembler, as.

</P>
<P>
DLLNAME is the name of the DLL you want to create, e.g., tcl80.dll.

</P>
<P>
OBJS is the list of object files you want to put into the DLL.

</P>
<P>
LIBS is the list of libraries you want to link the DLL against.  For
example, you may or may not want -lcygwin.  You may want -lkernel32.
Tcl links against -lcygwin -ladvapi32 -luser32 -lgdi32 -lcomdlg32
-lkernel32.

</P>
<P>
DEFFILE is the name of your definitions file.  A simple DEFFILE would
consist of "EXPORTS" followed by a list of all symbols which should
be exported from the DLL.  Each symbol should be on a line by itself.
Other programs will only be able to access the listed symbols.

</P>
<P>
BASEFILE is a temporary file that is used during this five stage
process, e.g., tcl.base.

</P>
<P>
EXPFILE is another temporary file, e.g., tcl.exp.

</P>
<P>
ENTRY is the name of the function which you want to use as the entry
point.  This function should be defined using the WINAPI attribute,
and should take three arguments:
        int WINAPI startup (HINSTANCE, DWORD, LPVOID)

</P>
<P>
This means that the actual symbol name will have an appended @12, so if
your entry point really is named <SAMP>`startup'</SAMP>, the string you should
use for ENTRY in the above examples would be <SAMP>`startup@12'</SAMP>.

</P>
<P>
If your DLL calls any Cygwin API functions, the entry function will need
to initialize the Cygwin impure pointer.  You can do that by declaring
a global variable <SAMP>`_impure_ptr'</SAMP>, and then initializing it in the
entry function.  Be careful not to export the global variable
<SAMP>`_impure_ptr'</SAMP> from your DLL; that is, do not put it in DEFFILE.

</P>

<PRE>
/* This is a global variable.  */
struct _reent *_impure_ptr;
extern struct _reent *__imp_reent_data;

int entry (HINSTANT hinst, DWORD reason, LPVOID reserved)
{
  _impure_ptr = __imp_reent_data;
  /* Whatever else you want to do.  */
}
</PRE>

<P>
You may put an optional `--subsystem windows' on the $(LD) lines.  The
Tcl build does this, but I admit that I no longer remember whether
this is important.  Note that if you specify a --subsytem &#60;x&#62; flag to ld,
the -e entry must come after the subsystem flag, since the subsystem flag
sets a different default entry point.

</P>
<P>
You may put an optional `--image-base BASEADDR' on the $(LD) lines.
This will set the default image base.  Programs using this DLL will
start up a bit faster if each DLL occupies a different portion of the
address space.  Each DLL starts at the image base, and continues for
whatever size it occupies.

</P>
<P>
Now that you've built your DLL, you may want to build a library so
that other programs can link against it.  This is not required: you
could always use the DLL via LoadLibrary.  However, if you want to be
able to link directly against the DLL, you need to create a library.
Do that like this:

</P>
<P>
$(DLLTOOL) --as=$(AS) --dllname DLLNAME --def DEFFILE --output-lib LIBFILE

</P>
<P>
$(DLLTOOL), $(AS), DLLNAME, and DEFFILE are the same as above.  Make
sure you use the same DLLNAME and DEFFILE, or things won't work right.

</P>
<P>
LIBFILE is the name of the library you want to create, e.g.,
libtcl80.a.  You can then link against that library using something
like -ltcl80 in your linker command.

</P>


<H2><A NAME="SEC86" HREF="faq_toc.html#TOC86">How can I debug what's going on?</A></H2>

<P>
You can debug your application using <CODE>gdb</CODE>.  Make sure you
compile it with the -g flag!  If your application calls functions in
MS dlls, gdb will complain about not being able to load debug information
for them when you run your program.  This is normal since these dlls
don't contain debugging information (and even if they did, that debug
info would not be compatible with gdb).

</P>


<H2><A NAME="SEC87" HREF="faq_toc.html#TOC87">Can I use a system trace mechanism instead?</A></H2>

<P>
Yes.  At the most basic level, you can set the <CODE>STRACE</CODE>
environment variable to <CODE>1</CODE>, and get a whole load of
debug information on your screen whenever a Cygwin app runs.
This is an especially useful tool to use when tracking bugs down
inside the Cygwin library.  <CODE>STRACE</CODE> can be set to different
values to achieve different amounts of granularity.  You can set it
to <CODE>0x10</CODE> for information about syscalls or <CODE>0x800</CODE> for
signal/process handling-related info, to name two.  The strace
mechanism is well documented in the Cygwin library sources in the
file <CODE>winsup/include/sys/strace.h</CODE>.

</P>


<H2><A NAME="SEC88" HREF="faq_toc.html#TOC88">The linker complains that it can't find something.</A></H2>

<P>
A common error is to put the library on the command line before
the thing that needs things from it.

</P>
<P>
This is wrong <CODE>gcc -lstdc++ hello.cc</CODE>.
This is right <CODE>gcc hello.cc -lstdc++</CODE>.

</P>


<H2><A NAME="SEC89" HREF="faq_toc.html#TOC89">I use a function I know is in the API, but I still get a link</A></H2>
<P>
error.

</P>
<P>
The function probably isn't declared in the header files, or
the UNICODE stuff for it isn't filled in.

</P>


<H2><A NAME="SEC90" HREF="faq_toc.html#TOC90">Can you make DLLs that are linked against libc ?</A></H2>

<P>
Yes.

</P>


<H2><A NAME="SEC91" HREF="faq_toc.html#TOC91">Where is malloc.h?</A></H2>

<P>
Include stdlib.h instead of malloc.h.

</P>


<H2><A NAME="SEC92" HREF="faq_toc.html#TOC92">Can I use my own malloc?</A></H2>

<P>
If you define a function called <CODE>malloc</CODE> in your own code, and link
with the DLL, the DLL <EM>will</EM> call your <CODE>malloc</CODE>.  Needless to
say, you will run into serious problems if your malloc is buggy.

</P>
<P>
If you run any programs from the DOS command prompt, rather than from in
bash, the DLL will try and expand the wildcards on the command line.
This process uses <CODE>malloc</CODE> <EM>before</EM> your main line is started.
If you have written your own <CODE>malloc</CODE> to need some initialization
to occur after <CODE>main</CODE> is called, then this will surely break.

</P>


<H2><A NAME="SEC93" HREF="faq_toc.html#TOC93">Can I mix objects compiled with msvc++ and gcc?</A></H2>

<P>
Yes, but only if you are combining C object files.  MSVC C++ uses a
different mangling scheme than GNU C++, so you will have difficulties
combining C++ objects.

</P>


<H2><A NAME="SEC94" HREF="faq_toc.html#TOC94">Can I use the gdb debugger to debug programs built by VC++?</A></H2>

<P>
No, not for full (high level source language) debugging.
The Microsoft compilers generate a different type of debugging
symbol information, which gdb does not understand.

</P>
<P>
However, the low-level (assembly-type) symbols generated by
Microsoft compilers are coff, which gdb DOES understand.
Therefore you should at least be able to see all of your
global symbols; you just won't have any information about
data types, line numbers, local variables etc.

</P>


<H2><A NAME="SEC95" HREF="faq_toc.html#TOC95">Where can I find info on x86 assembly?</A></H2>

<P>
CPU reference manuals for Intel's current chips are available in
downloadable PDF form on Intel's web site:

</P>
<P>
<TT><a target="_top" href="http://developer.intel.com/design/pro/manuals/">http://developer.intel.com/design/pro/manuals/</a></TT>

</P>


<H2><A NAME="SEC96" HREF="faq_toc.html#TOC96">Shell scripts aren't running properly from my makefiles?</A></H2>

<P>
You need to have . (dot) in your $PATH.  You should NOT need to add
/bin/sh in front of each and every shell script invoked in your
Makefiles.

</P>


<H2><A NAME="SEC97" HREF="faq_toc.html#TOC97">What preprocessor do I need to know about?</A></H2>

<P>
We use _WIN32 to signify access to the Win32 API and __CYGWIN__ for
access to the Cygwin environment provided by the dll.

</P>
<P>
We chose _WIN32 because this is what Microsoft defines in VC++ and
we thought it would be a good idea for compatibility with VC++ code
to follow their example.  We use _MFC_VER to indicate code that should
be compiled with VC++.

</P>


<H2><A NAME="SEC98" HREF="faq_toc.html#TOC98">Where can I get f77 and objc components for B20 EGCS 1.1?</A></H2>

<P>
B20-compatible versions of the f77 and objc components are available
from <TT><a target="_top" href="http://www.xraylith.wisc.edu/~khan/software/gnu-win32/">http://www.xraylith.wisc.edu/~khan/software/gnu-win32/</a></TT>.

</P>


<H2><A NAME="SEC99" HREF="faq_toc.html#TOC99">How should I port my Unix GUI to Windows?</A></H2>

<P>
There are two basic strategies for porting Unix GUIs to Windows.

</P>
<P>
The first is to use a portable graphics library such as tcl/tk, X11, or
V (and others?).  Typically, you will end up with a GUI on Windows that
requires some runtime support.  With tcl/tk, you'll want to include the
necessary library files and the tcl/tk DLLs.  In the case of X11, you'll
need everyone using your program to have an X11 server installed.

</P>
<P>
The second method is to rewrite your GUI using Win32 API calls (or MFC
with VC++).  If your program is written in a fairly modular fashion, you
may still want to use Cygwin if your program contains a lot of shared
(non-GUI-related) code.  That way you still gain some of the portability
advantages inherent in using Cygwin.

</P>


<H2><A NAME="SEC100" HREF="faq_toc.html#TOC100">Why not use DJGPP ?</A></H2>

<P>
DJGPP is a similar idea, but for DOS instead of Win32.  DJGPP uses a
"DOS extender" to provide a more reasonable operating interface for its
applications.   The Cygwin toolset doesn't have to do this since all of
the applications are native WIN32.   Applications compiled with the
Cygwin tools can access the Win32 API functions, so you can write
programs which use the Windows GUI.

</P>
<P>
You can get more info on DJGPP by following
<TT><a target="_top" href="http://www.delorie.com/">http://www.delorie.com/</a></TT>.
<P><HR><P>
Go to the <A HREF="faq_1.html">first</A>, <A HREF="faq_8.html">previous</A>, <A HREF="faq_10.html">next</A>, <A HREF="faq_13.html">last</A> section, <A HREF="faq_toc.html">table of contents</A>.

