#!/usr/bin/perl
use DBI;
use File::Find;
use Mail::Send;
use Getopt::Long;
use HTTP::Status;
use LWP::UserAgent;
use CGI qw/:standard start_ul end_ul/;
use Time::localtime;

use constant {
    MAXRETRY => 5,
    NOCHECK_THRESHOLD => 100,
    FILE_OUTOFDATE => 'File(s) out of date',
    SITE_OUTOFDATE => 'Site out of date',
    TMPFILE => '/tmp/checkmirror.' . $$
};

$SIG{TERM} = $SIG{HUP} = $SIG{INT} = $SIG{__DIE__} = sub {unlink TMPFILE};
use integer;
use strict;

sub isgoodmirror($$);
sub makeweb($);
sub makemaster($);
sub rsync($$);
our $ex = 0;

my @email = ();
my $flush = 0;
my $webpage = '';
my $match;
my $master;
my $summary = 1;
my $nreferences = 3;
GetOptions('mail|email=s'=>\@email, 'n|use-references=i'=>\$nreferences, 'master=s'=>\$master, 'match=s'=>\$match, 'summary!'=>\$summary, 'flush!'=>\$flush, 'webpage=s'=>\$webpage) or exit 1;

our $release_dir = shift;
$release_dir .= '/' unless substr($release_dir, -1) eq '/';

our $ua = LWP::UserAgent->new;

our %md5sums = ();
our %visited = ();

find(\&wanted, $release_dir);
undef %visited;

our @newest = ();
for (sort {$b <=> $a} keys %md5sums) {
    my $fn = $release_dir . '/' . $md5sums{$_};
    open MD5SUM, '<', $fn or die "$0: *** couldn't open $fn - $!\n";
    push @newest, [$md5sums{$_}, join('', <MD5SUM>)];
    close MD5SUM;
    last if @newest >= $nreferences;
}
undef %md5sums;

my $dbh = DBI->connect('dbi:mysql:dbname=cygwin', 'root', 'stoptryingtolookatmysql');
my $update = $dbh->prepare('UPDATE mirrors set lasterror = ?, count = ?, lastcheck = ? where url = ?');
my $sth = $dbh->prepare("SELECT * FROM mirrors");
$sth->execute();

our %goodmirrors = ();
our %badmirrors = ();
my ($ngood, $nbad, $nood) = (0, 0, 0);
while (my $ref = $sth->fetchrow_hashref()) {
    my $url = $ref->{url};
    next if $ref->{count} >= NOCHECK_THRESHOLD || (defined($match) && $url !~ /$match/o);
    my $err = isgoodmirror($ref, $flush);
    if (!length($err)) {
	$ref->{count} = 0;
	$ngood++;
    } else {
	$ref->{count}++ unless $flush;
	$badmirrors{$url} = [$err, $ref->{count}];
	if ($err eq FILE_OUTOFDATE) {
	    $nood++;
	} else {
	    $nbad++
	}
    }

    push @{$goodmirrors{$ref->{country}}{$ref->{region}}}, $ref
	if !length($err) || $err eq FILE_OUTOFDATE;
    next if $flush;
    $ref->{lasterror} = $err;
    $ref->{lastcheck} = time;
    $update->execute($ref->{lasterror}, $ref->{count}, $ref->{lastcheck}, $url);
}

makeweb($webpage) if $webpage;
makemaster($master) if $master;
undef $dbh;

if ($summary) {
    my ($msg, $fh);
    if (!@email) {
	$fh = \*STDOUT;
    } else {
	$msg = Mail::Send->new(Subject=>'check-mirrors report');
	$msg->to(@email);
	$fh = $msg->open;
    }

    printf $fh <<EOF, $ngood, $nood, $nbad;
    Number of working mirrors:    .%3d
    Number of out-of-date mirrors: %3d
    Number of nonworking mirrors:  %3d

    Reference files:
EOF
    print $fh '    ', $_->[0], "\n" for @newest;

    if ($nbad) {
	print $fh "\nError                                     Retries  URL\n";
	for my $url (sort keys %badmirrors) {
	    my ($err, $count) = @{$badmirrors{$url}};
	    printf $fh "%-40.40s  %5d    %s\n", $err, $count, $url;
	}
    }
    close $fh;
}

unlink TMPFILE;
exit $ex;

sub get($\$) {
    my $url = shift;
    my $value = shift;
    return rsync($url, $value) if substr($url, 0, 6) eq 'rsync:';
    my $req = HTTP::Request->new(GET => $url);
    my $res = $ua->request($req);
    if ($res->is_success) {
	$$value = $res->content;
	return '';
    }
    (my $message = $res->message) =~ s/^LWP:\S+\s+//o;
    $message ||= $res->status_line;
    chomp $message;
    return $message;
}

sub isgoodmirror($$) {
    my $ref = shift;
    my $flush = shift;
    return $ref->{lasterror} if $flush;
    my $err;
    for (@newest) {
	my ($fn, $content) = @$_;
	my $value;
	my $url = $ref->{url} . 'release/' . $fn;
	my $rc = get($url, $value);
	if (length($rc)) {
	    $err = $rc;
	    last;
	}
	$err = ($ref->{count} >= MAXRETRY) ? SITE_OUTOFDATE : FILE_OUTOFDATE
	    if $value ne $content && !defined($err);
    }
    return $err;
}

sub wanted {
    next if -l $File::Find::name || -d _;
    my @st;
    my $md5sum =  $File::Find::dir . '/' . 'md5.sum';
    my $md5sum_short = substr($md5sum, length($release_dir));
    if (!defined($visited{$File::Find::dir})) {
	@st = stat($md5sum);
	return if !@st;
	$visited{$File::Find::dir} = $st[9];
	$md5sums{$st[9]} = $md5sum_short;
    }
    @st = stat($File::Find::dir);
    return if !@st;
    my $md5stat = $visited{$File::Find::dir};
    delete $md5sums{$md5stat} if $st[9] > $md5stat && $md5sums{$md5stat} eq $md5sum_short;
}

sub reforder {
    return $a->{'url'} cmp $b->{'url'}
}

sub makeweb($) {
    my $file = shift;
    my $page;
    my $pretty_date = sprintf "%4d-%02d-%02d %02d:%02d", 1900 + localtime->year, localtime->mon + 1, localtime->mday, localtime->hour, localtime->min;
    open X, '>', \$page;
    print X "<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en-US\" xml:lang=\"en-US\">\n",
	    "<head><title>Untitled Document</title>\n",
	    "<!--#include virtual=\"cygwin-header.html\"-->\n",
	    h2({-align=>'center'}, 'Mirror Sites as of ' . $pretty_date . ' GMT'),
	    <<EOF, h3('Site List:'), "\n";

<P>The following sites have generously agreed to mirror our main Cygwin
ftp site.  To save you download time, please choose the one nearest
to you!

<p><em>Note:</em> We maintain a list of sites who have indicated that
they are acting as mirrors of the full cygwin FTP area.  We
<em>automatically</em> poll this list on a regular basis to determine if these
sites are currently up-to-date.  The list of sites below reflects all of
the sites who appear to be on-line and acting as mirrors.</p>

<p>If you are a mirror site administrator and your site was previously
listed but has dropped off that means that the automatic software has
determined that you are not up-to-date.  Your site will be re-added
automatically when you become current.  There is no need to contact
anyone about this.</p>

<p>If a site is listed here that seems to be out-of-date for some period
of time, that could mean that there is a problem.  Contact sourcemaster
at this site to report this potential problem.  sourcemaster is also the
place to send requests to be added to this list.</p>

EOF
    print X start_ul(), "\n";
    for my $country (sort keys %goodmirrors) {
	print X '<li>', $country, ":\n", start_ul(), "\n";
	my $regions = $goodmirrors{$country};
	for my $region (sort keys %{$regions}) {
	    print X '<li>',$region, ': ';
	    my @refs = sort reforder @{$regions->{$region}};
	    while (my $ref = shift @refs) {
		my ($proto, $purl) = $ref->{url} =~ m%^(.*?)://([^/]+)/%o;
		print X a({href=>$ref->{url}}, $purl), "($proto)";
		print X ', ' if @refs;
	    }
	    print X "</li>\n";
	}
	print X "</li>\n", end_ul(), "\n";
    }
    print X end_ul(), "\n", end_html(), "\n";
    close X;
    open F, '>', $file or do {
	warn "$0: couldn't open $file for writing - $!\n";
	$ex = 1;
	return;
    };
    print F $page;
    close F;
    chmod 0755, $file;
}

sub rsync($$) {
    my $url = shift;
    my $value = shift;
    my $err = '';
    unlink TMPFILE;
    open RSYNC, '-|' or do {
	$SIG{TERM} = $SIG{HUP} = $SIG{INT} = $SIG{__DIE__} = 'IGNORE';
	open STDERR, '>&STDOUT';
	open STDOUT, '>', '/dev/null';
	open STDIN, '<', '/dev/null';
	exec '/usr/bin/rsync', '-W', $url, TMPFILE or
	  die "$0: couldn't execute rsync - $!\n";
    };
    my @errs = <RSYNC>;
    close RSYNC;
    if ($? != 0) {
	$err = $errs[0];
	chomp $err;
    } elsif (!open T, '<', TMPFILE) {
	warn "$0: couldn't open " . TMPFILE . " - $!\n";
	$err = 'File not transferred';
    } else {
	$$value = join('', <T>);
	close T;
    }
    return $err;
}

sub makemaster($) {
    my $file = shift;
    my $master;
    open MASTER, '>', $file or do {
	warn "$0: couldn't open $file - $!\n";
	$ex = 1;
	return;
    };
    for my $country (sort keys %goodmirrors) {
	my $regions = $goodmirrors{$country};
	for my $region (sort keys %$regions) {
	    for my $ref (sort reforder @{$regions->{$region}}) {
		my ($proto, $purl) = $ref->{url} =~ m%^(.*?)://([^/]+)/%o;
		next if $proto eq 'rsync';
		print MASTER join(';', $ref->{url}, $purl, $ref->{'country'}, $ref->{'region'}), "\n";
	    }
	}
    }
    close MASTER;
    return;
}
