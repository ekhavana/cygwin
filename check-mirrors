#!/usr/bin/perl
# -*- perl -*-

open(M, "mirrors.txt");
$out = "mirrors.html";

$header = '<HTML>
<HEAD>
<TITLE>Download Cygwin</TITLE>
</HEAD>

<!--#include virtual="cygwin-header.html"-->

<h2 align=middle>Mirror Sites</h2>

<P>The following sites have generously agreed to mirror our main Cygwin
ftp site.  To save you download time, please choose the one nearest
to you!

<H3>FTP Sites:</H3>
';

$trailer = '
<P> Optionally you can download from Cygnus'."'".' busy site, 
<a href="ftp://sourceware.cygnus.com/pub/cygwin/">sourceware.cygnus.com</a>.

<P> Regardless of the origin of the tools, please be sure to read the <a
href="readme_toc.html">README</a> file which explains how to get
get everything working, starting with the installation process.

<P>Enjoy!

<!--#include virtual="cygwin-footer.html"-->
';

open(STDOUT, "| /usr/lib/sendmail -t -odi -oep -oi");
open(STDERR, ">&STDOUT");

print "To: dj\@delorie.com\n";
print "Subject: cygwin mirror status\n";
print "\n";

#----------------------------------------------------------------------

$| = 1;

use IO::Socket;

$days = 86400;
$now = time;
$master = <M>;
$master =~ s/[\r\n]+$//;
$best_mtime = 0;
$best_file = undef;
open(F, "cd $master; find * -type f -print |");
while (<F>) {
    s/[\r\n]+$//;
    $mtime = $now - (stat("$master/$_"))[9];
    next if $mtime < 7*$days;
    if (! $best_file || $best_mtime > $mtime) {
	$best_file = $_;
	$best_mtime = $mtime;
    }
}
close(F);
print "Key file is $best_file\n";

while (<M>) {
    next if /^#/;
    ($url, $area, $region) = split(/[;\r\n]+/);
    next unless $area;
    $url =~ s@/+$@@;
    ($proto, $site, $dir) = $url =~ m@([a-z]+)://([^/]+)(.*)@;
    $dir = "/" unless $dir;
    $ok = 0;
    $ok = &verify_ftp($site, "$dir/$best_file") if ($proto eq "ftp");
    $ok = &verify_http($site, "$dir/$best_file") if ($proto eq "http");

    if ($ok) {
	print "OK:  $url\n";
	push(@ok, "$region;$area;$url;$site");
    }
    else
    {
	print "BAD: $url\n";
    }
}

close(M);

$oldregion = '';
$oldarea = '';

open(OUT, "> $out");

print OUT "\n";
print OUT "<!-- WARNING: This file is generated by check-mirrors.\n";
print OUT "     DO NOT EDIT or your changes will be lost!  Edit mirrors.txt\n";
print OUT "     instead!  (cron job runs nightly via dj's account)  -->\n";
print OUT "\n";
print OUT "<ul>";

print $header;

for $ok (sort @ok) {
    ($region, $area, $url, $site) = split(';', $ok);
    if ($region ne $oldregion) {
	print OUT "\n</ul>\n" if $oldarea;
	print OUT "<li>$region:\n";
	print OUT "<ul>";
	$oldregion = $region;
	$oldarea = '';
    }
    if ($area ne $oldarea) {
	print OUT "<li>$area:\n";
	$oldarea = '';
    }
    print OUT ",\n" if $oldarea;
    print OUT "<a href=\"$url/\">$site</a>";
    $oldarea = $area;
}
print OUT "\n</ul>\n" if $oldarea;
print OUT "</ul>\n" if $oldregion;

print $trailer;

close(OUT);

#---------------------------------------------------------------------

sub pingable {
    return 1;
    my($site) = @_;
    print "pinging $site...";
    # this doesn't do what you expect on linux.  Sigh.
    open(PING, "ping -c 4 $site 2>/dev/null|");
    $ping_ok = 0;
    $ping_count = 0;
    while (<PING>) {
	if ($ping_count++ > 10) {
	    print "bag it, got junk\n";
	    close(PING);
	    return 1;
	}
	if (/bytes from/) {
	    print "got it\n";
	    close(PING);
	    return 1;
	}
	if (/Packet filtered/) {
	    print "filter, assuming OK\n";
	    close(PING);
	    return 1;
	}
    }
    print "no luck\n";
    close(PING);
    return 0;
}

#---------------------------------------------------------------------

sub verify_http {
    my ($site, $file) = @_;
    if (!&pingable($site)) {
	print "$site: can't ping\n";
	return 0;
    }
    $http = IO::Socket::INET->new(PeerAddr => $site,
				  PeerPort => 80,
				  Proto => "tcp");
    return 0 unless defined $http;
    $http->autoflush(1);
    print $http "HEAD $file HTTP/1.0\r\n\r\n";
    $status = <$http>;
    0 while <$http>;
    close $http;
    return 1 if $status =~ / 200 /;
    return 0;
}

#---------------------------------------------------------------------

sub verify_ftp {
    my ($site, $file) = @_;
    if (&ftp_open($site)) {
	print "$site: can't open\n";
	return 0;
    }
    if (&ftp_login("anonymous", "dj\@cygnus.com")) {
	print "$site: can't login\n";
	return 0;
    }
    if (&ftp_dir_open($file)) {
	print "$site: can't dir\n";
	return 0;
    }
    ($basefile = $file) =~ s@.*/@@;
    $found = 0;
    while ($d = <$ftp_data>) {
	$found = 1 if $d =~ /$basefile/;
    }
    &ftp_dir_close();
    &ftp_close();
    if ($found) {
	return 1;
    }
    return 0;
}

######################################################################

sub ftp_debug {
    $ftp_debug_level = $_[0];
}

sub ftp_command {
    my ($command) = @_;
    if (defined $command) {
	print "ftp > $command\n" if $ftp_debug_level;
	print $ftp_control "$command\n";
    }
    do {
	$ftp_response = <$ftp_control>;
	print "ftp < $ftp_response" if $ftp_debug_level;
	if (! $ftp_response) {
	    print "FTP Error: EOF" if $ftp_debug_level;
	    return 1;
	}
    } until $ftp_response =~ /^\d\d\d /;
    $ftp_response =~ s/[\r\n]+$//;
    if ($ftp_response =~ /^[4-9]/) {
	print STDERR "FTP Error: $ftp_response\n";
	return 1;
    }
    return 0;
}

sub ftp_open {
    my ($site) = @_;
    $ftp_save_site = $site;
    if (!&pingable($site)) {
	print "$site: can't ping\n";
	return 1;
    }
    $ftp_control = IO::Socket::INET->new(PeerAddr => $site,
					 PeerPort => 21,
					 Proto => "tcp");
    if (!defined $ftp_control) {
	print "unable to connect to $site: $!\n" if $ftp_debug_level;
	return 1;
    }
    &ftp_command() && return 1;
    return 0;
}

sub ftp_login {
    my ($user, $password) = @_;
    $ftp_save_user = $user;
    $ftp_save_password = $password;
    &ftp_command("USER $user") && return 1;
    if ($ftp_response =~ /^331/) {
	&ftp_command("PASS $password") && return 1;
    }
    &ftp_command("TYPE I");
    return 0;
}

sub ftp_cwd {
    my ($dir) = @_;
    $ftp_save_dir = $dir;
    return &ftp_command("CWD $dir");
}

sub ftp_open_data_port {
    return 0 if $ftp_data_port_ready;
    &ftp_command("PASV");
    my ($h1,$h2,$h3,$h4,$p1,$p2) = $ftp_response =~ /\((\d+),(\d+),(\d+),(\d+),(\d+),(\d+)\)/;
    $p1 = $p1 * 256 + $p2;
    print "PASV: $h1.$h2.$h3.$h4 port $p1\n" if $ftp_debug_level > 1;
    $ftp_data = IO::Socket::INET->new(PeerAddr => "$h1.$h2.$h3.$h4",
				      PeerPort => $p1,
				      Proto => "tcp");

    if (! defined $ftp_data) {
	return 1;
    }
    $ftp_data_port_ready = 1;
    return 0;
}


sub ftp_close_data_port {
    close $ftp_data;
    $ftp_data_port_ready = 0;
}

sub ftp_get {
    my ($remote_name, $local_file) = @_;
    open(FTP_F, ">$local_file") || return 1;
    if (&ftp_open_data_port()) {
	print "ftp pasv failed: $ftp_response\n";
	if ($ftp_response =~ /timeout/i) {
	    print "ftp: attempting to re-establish the connection\n";
	    &ftp_open($ftp_save_site) && return 1;
	    &ftp_login($ftp_save_user, $ftp_save_password) && return 1;
	    &ftp_cwd($ftp_save_dir) && return 1;
	    &ftp_open_data_port() && return 1;
	} else {
	    return 1;
	}
    }
    &ftp_command("RETR $remote_name") && return 1;
    print FTP_F $ftp_buffer while read($ftp_data, $ftp_buffer, 4096) > 0;
    close(FTP_F);
    &ftp_close_data_port();
    return &ftp_command();
}

sub ftp_close {
    &ftp_command("quit");
    close $ftp_control;
    return;
}

sub ftp_dir_open {
    my ($options) = @_;
    &ftp_open_data_port();
    $options = " $options" if $options;
    &ftp_command("LIST$options");
    $ftp_data_port_ready = 0;
}

sub ftp_dir_close {
    &ftp_close_data_port();
    return &ftp_command();
}
