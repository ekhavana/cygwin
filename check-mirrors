#!/usr/bin/perl
# -*- perl -*-
#
# Copyright 2000,2001 Red Hat, Inc.
#

use strict;

use Net::FTP;
use LWP::Simple;
use File::Find;
use File::stat;

open(M, "mirrors.txt");
my $out = "mirrors.html";
my $state = "mirrors.state";
my $list = "mirrors.lst";
my $MINDAYS = 3;

sub siteprint($$;@);

$main::timeout = 120;

my $header = '<HTML>
<HEAD>
<TITLE>Download Cygwin</TITLE>
</HEAD>

<!--#include virtual="cygwin-header.html"-->

<h2 align=middle>Mirror Sites</h2>

<P>The following sites have generously agreed to mirror our main Cygwin
ftp site.  To save you download time, please choose the one nearest
to you!

<p><em>Note:</em> We maintain a list of sites who have indicated that
they are acting as mirrors of the full cygwin FTP area.  We
<em>automatically</em> poll this list on a regular basis to determine if these
sites are currently available.  The list of sites below reflects all of
the sites who appear to be on-line and acting as mirrors.</p>
<p>If you are a mirror site administrator and your site was previously
listed but has dropped off that means that the automatic software has
determined that you are not up-to-date.  Your site will be re-added
automatically when you become current.  There is no need to contact
anyone about this.</p>

<p>If a site is listed here that seems to be out-of-date for some period
of time, that could mean that there is a problem.  Contact sourcemaster
at this site to report this potential problem</p>.

<H3>Mirror Sites:</H3>
';

my $trailer = '
<P>Enjoy!

<!--#include virtual="cygwin-footer.html"-->
';

open(STDOUT, "> /tmp/check-mirrors.out");
open(STDERR, ">&STDOUT");
$| = 1;


my $summary .= "start at " . scalar localtime() . "\n";

#----------------------------------------------------------------------

my $site;
my %oldstate;
open(STATE, $state);
while (<STATE>) {
    my $ok;
    ($site, $ok) = split;
    $oldstate{$site} = $ok;
}
close(STATE);

$| = 1;

my $days = 86400;
my $now = time;
my $master = <M>;
$master =~ s/[\r\n]+$//;
my $dir = ($master =~ m%/([^/]+)$%)[0];
$main::best_mtime = 0;
$main::main::best_file = undef;
find({wanted=>\&wanted, follow_fast=>1, no_chdir=>1}, $master);
substr($main::best_file, 0, length($master) + 1) = '';
$main::best_file = "$dir/$main::best_file";
print "Key file is $main::best_file\n";

my (@ok, $ok_count, $bad_count);
$ok_count = $bad_count = 0;

while (<M>) {
    next if /^#/;
    my $ok = 0;
    my ($url, $area, $region) = split(/[;\r\n]+/);
    next unless $area;
    if ($url =~ /^\+/) {
	$ok = 1;
	$url =~ s/^\+//;
    }
    $url =~ s@/+$@@;
    my ($proto, $site, $dir) = $url =~ m@([a-z]+)://([^/]+)(.*)@;
    $dir = "/" unless $dir;
    $ok = verify_with_timeout($proto, $site, "$dir/$main::best_file") unless $ok;
    if ($ok == 2) {
	$ok = $oldstate{$site} + 0;
	siteprint $site, $proto, "too many anon users, assuming ok";
    }
    my $oldstate = $oldstate{$site};
    $oldstate{$site} = $ok;
    if (!$ok && $oldstate) {
	$ok = 1;
	siteprint $site, $proto, "resetting status to $ok";
    }

    if ($ok) {
	$summary .= "OK   $url\n";
	$ok_count ++;
	siteprint $site, $proto, "OK";
	push(@ok, "$region;$area;$url;$site");
    } else {
	$summary .= "BAD  $url\n";
	$bad_count ++;
	siteprint $site, $proto, "BAD";
    }
}

close(M);

open(STATE, ">$state");
for my $k (sort keys %oldstate) {
    print STATE "$k $oldstate{$k}\n";
}
close(STATE);

my $oldregion = '';
my $oldarea = '';

open(SUMMARY, "| /usr/lib/sendmail -t -odi -oep -oi");
print SUMMARY "To: cgf\@redhat.com\n";
print SUMMARY "Subject: cygwin mirror summary\n";
print SUMMARY "\n";
print SUMMARY "\n$ok_count ok, $bad_count bad\n\n";
print SUMMARY $summary;
print SUMMARY "done at ", scalar localtime(), "\n";
close SUMMARY;

open(OUT, "> $out");
open(LIST, "> $list");

print OUT "\n";
print OUT "<!-- WARNING: This file is generated by check-mirrors.\n";
print OUT "     DO NOT EDIT or your changes will be lost!  Edit mirrors.txt\n";
print OUT "     instead!  (a cron job runs regularly)  -->\n";
print OUT "\n";

print LIST "# Do not edit - see warning in mirrors.html\n";

print OUT $header;

print OUT "<ul>";
for my $ok (sort @ok) {
    my ($region, $area, $url, $site) = split(';', $ok);
    if ($region ne $oldregion) {
	print OUT "\n</ul>" if $oldarea;
	print OUT "\n<li>$region:\n";
	print OUT "\n<ul>";
	$oldregion = $region;
	$oldarea = '';
    }
    if ($area ne $oldarea) {
	print OUT "<li>$area:\n";
	$oldarea = '';
    }
    print OUT ",\n" if $oldarea;
    print OUT "<a href=\"$url/\">$site</a>";
    print LIST "$url;$site;$region;$area\n";
    $oldarea = $area;
}
print OUT "\n</ul>\n" if $oldarea;
print OUT "</ul>\n" if $oldregion;

print OUT $trailer;

close(OUT);
close(LIST);

close(STDERR);
close(STDOUT);
exit(0);

#---------------------------------------------------------------------

sub siteprint($$;@) {
    my $site = shift;
    my $proto = shift;
    print "$site($proto): @_\n";
}

sub verify_with_timeout {
    my ($proto, $site, $file) = @_;
    my $pid = fork();
    return 0 if $pid < 0;
    if ($pid == 0) {
	$| = 1;
	print "**********************\n";
	siteprint $site, $proto, $file;
	if ($proto eq "ftp") {
	   exit verify_ftp($site, $file);
	} else {
	   exit verify_http($site, $file);
	}
    }
    $SIG{ALRM} = sub {
	kill 9, $pid;
	siteprint $site, $proto, "timed out";
    };
    alarm($main::timeout);
    my $rv;
    if (waitpid($pid, 0) != $pid) {
	$rv = 0;
    } else {
	$rv = $? >> 8;
    }
    alarm(0);
    undef $SIG{ALRM};
    siteprint $site, $proto, "status $rv $file";
    return $rv;
}

#---------------------------------------------------------------------

sub verify_http {
    my ($site, $file) = @_;
    my $url = "http://$site/$file";
    my @result = LWP::Simple::head($url);
    my $status = @result == 5 ? 1 : 0;
    if ($status) {
	print "$file -- ", join(';', @result), "\n";
    } else {
	siteprint $site, 'http', "$file not found";
    }
    return $status;
}

#---------------------------------------------------------------------

sub congested {
    my ($site, $msg) = @_;
    if ($msg =~ /too many|exceed|limit/mi) {
	siteprint $site, 'ftp', "status 2 - congested";
	return 1;
    }
    return 0;
}

sub verify_ftp {
    my ($site, $file) = @_;
    my $ftp = Net::FTP->new($site);
    if (!$ftp) {
	print $@;
	return 2 if congested($site, $@);
	siteprint $site, 'ftp', "can't open";
	return 0;
    }
    print $ftp->message;
    siteprint $site, 'ftp', "open";
    my $rc = $ftp->login('anonymous', 'sourcemaster@sourceware.org');
    my $msg = $ftp->message;
    print $msg;
    if (!$rc) {
	return 2 if congested($site, $msg);
	siteprint $site, 'ftp', "can't login";
	return 0;
    }
    my @a = $ftp->ls($file);
    print "@a\n";
    my $status = @a;
    if (!$status) {
	siteprint $site, 'ftp', "$file not found";
	return 0;
    }
    $ftp->quit;
    return $status;
}

sub wanted {
    return unless /\.tar/;
    return if $File::Find::name =~ m@private|old|md5\.sum|xfree|mail-archives|snapshots@;
    my $st = stat($File::Find::name);
    return unless $st->size;
    my $mtime = $now - $st->mtime;
    next if $mtime < $MINDAYS * $days;
    if (!$main::best_file || $main::best_mtime > $mtime) {
	$main::best_file = $File::Find::name;
	$main::best_mtime = $mtime;
    }
}
