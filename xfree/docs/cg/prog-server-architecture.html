<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Cygwin/XFree86 X Server
Architecture</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"/><LINK
REL="HOME"
TITLE="Cygwin/XFree86 Contributor's Guide"
HREF="cygwin-xfree-cg.html"/><LINK
REL="UP"
TITLE="Programming"
HREF="programming.html"/><LINK
REL="PREVIOUS"
TITLE="Source Code Tree Layout"
HREF="prog-tree-layout.html"/><LINK
REL="NEXT"
TITLE="Obtaining the Source Code"
HREF="prog-obtaining-source.html"/></HEAD
><BODY
CLASS="sect1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Cygwin/XFree86 Contributor's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="prog-tree-layout.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Programming</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="prog-obtaining-source.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"/></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="prog-server-architecture"
>Cygwin/XFree86 X Server
Architecture</A
></H1
><P
>Cygwin/XFree86's X Server architecture was heavily inspired by <A
HREF="biblio.html#porting-layer-definition"
>Angebranndt94</A
>, the Definition of the
Porting Layer for the X v11 Sample Server.</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="prog-server-architecture-privates"
>Server Privates</A
></H2
><P
>X Servers use various structures to pass information around to
functions.  Some of those structures are colormaps, <A
HREF="glossary.html#gloss-gc"
><I
CLASS="glossterm"
>graphics contexts</I
></A
> (GCs), <A
HREF="glossary.html#gloss-pixmap"
><I
CLASS="glossterm"
>pixmaps</I
></A
>, and <A
HREF="glossary.html#gloss-screen"
><I
CLASS="glossterm"
>screens</I
></A
>.  The X protocol defines
the contents of each of these structures, however, the X Server
implementation and various X Server libraries (<A
HREF="glossary.html#gloss-mi-layer"
><I
CLASS="glossterm"
>MI</I
></A
>, <A
HREF="glossary.html#gloss-fb-layer"
><I
CLASS="glossterm"
>FB</I
></A
>, <A
HREF="glossary.html#gloss-shadow-layer"
><I
CLASS="glossterm"
>Shadow</I
></A
>, etc.)  may require
additional information to be associated with these internal
structures.  For example, the Cygwin/XFree86 X Server must associate a
Windows window handle (hwnd) with each X Server screen that is
open.</P
><P
><A
HREF="glossary.html#gloss-privates"
><I
CLASS="glossterm"
>Privates</I
></A
> are the
mechanism provided by the X protocol for associating additional
information with internal X Server structures.  Privates originally
consisted of a single pointer member contained in each structure,
usually named <TT
CLASS="structfield"
><I
>devPrivate</I
></TT
> or
<TT
CLASS="structfield"
><I
>devPriv</I
></TT
>.  This original specification only
allowed one of the X Server layers (mi, fb, shadow, etc.) to have
privates associated with an internal structure.  Privates have since
been revised.</P
><P
>The current privates implementation requires that each X Server
layer call a function on startup to indicate that that layer will
require privates and to obtain an index into the array of privates
that that layer's privates will be stored at.  Modern privates are
generally stored in an array of type <SPAN
CLASS="structname"
>DevUnion</SPAN
>
pointed to by a structure member named
<TT
CLASS="structfield"
><I
>devPrivates</I
></TT
>;
<SPAN
CLASS="structname"
>DevUnion</SPAN
> is defined in
<TT
CLASS="filename"
>xc/programs/Xserver/include/miscstruct.h</TT
>.  There
are two different memory allocation schemes for
<TT
CLASS="structfield"
><I
>devPrivates</I
></TT
>.</P
><P
>Memory for privates structures can either be preallocated or
allocated upon use.  Preallocation, the preferred method for GCs,
pixmaps, and windows, requires that the size of the privates memory
needed be specified during X Server initialization.  Preallocation
allows the <A
HREF="glossary.html#gloss-dix-layer"
><I
CLASS="glossterm"
>DIX</I
></A
> layer
to allocate all memory needed for a given internal structure,
including all privates memory, as a single contiguous block of memory;
this greatly reduces memory fragmentation.  Allocation upon use, used
by screens, requires the <A
HREF="glossary.html#gloss-ddx-layer"
><I
CLASS="glossterm"
>DDX</I
></A
> structure creation function
to allocate memory for the privates;
<TT
CLASS="function"
>winScreenInit</TT
> calling
<TT
CLASS="function"
>winAllocatePrivates</TT
>, which allocates screen
privates memory directly, is an example of this.  Allocation upon use
can optionally and non-optimally be used by GCs, pixmaps, and
windows.</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-privates-macros"
>Macros</A
></H3
><P
>Three macros are provided for each class of privates that make
setting up and using the privates easier.  The macros for screen
privates are examined as an example.</P
><DIV
CLASS="funcsynopsis"
><A
NAME="AEN301"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>winPrivScreenPtr <B
CLASS="FSFUNC"
>winGetScreenPriv</B
></CODE
>(ScreenPtr <VAR
CLASS="PDPARAM"
>pScreen</VAR
>);</CODE
></P
></DIV
><P
><TT
CLASS="function"
>winGetScreenPriv</TT
> takes a non-NULL pointer
to a screen, a <SPAN
CLASS="type"
>ScreenPtr</SPAN
>, and returns the pointer stored
in the DDX privates for that screen.  Passing a NULL or invalid
<SPAN
CLASS="type"
>ScreenPtr</SPAN
> to <TT
CLASS="function"
>winGetScreenPriv</TT
> will
cause an access violation, crashing the Cygwin/XFree86 X Server.</P
><DIV
CLASS="funcsynopsis"
><A
NAME="AEN312"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>winSetScreenPriv</B
></CODE
>(ScreenPtr <VAR
CLASS="PDPARAM"
>pScreen</VAR
>, void * <VAR
CLASS="PDPARAM"
>pvPrivates</VAR
>);</CODE
></P
></DIV
><P
><TT
CLASS="function"
>winSetScreenPriv</TT
> takes a non-NULL pointer
to a screen, a <SPAN
CLASS="type"
>ScreenPtr</SPAN
>, and sets the DDX privates
pointer to the value of the <TT
CLASS="parameter"
><I
>pvPrivates</I
></TT
>
parameter.  Passing a NULL or invalid <SPAN
CLASS="type"
>ScreenPtr</SPAN
> to
<TT
CLASS="function"
>winSetScreenPriv</TT
> will cause an access violation,
crashing the Cygwin/XFree86 X Server.</P
><DIV
CLASS="funcsynopsis"
><A
NAME="AEN326"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>winScreenPriv</B
></CODE
>(ScreenPtr <VAR
CLASS="PDPARAM"
>pScreen</VAR
>);</CODE
></P
></DIV
><P
><TT
CLASS="function"
>winScreenPriv</TT
> takes a non-NULL pointer to a
screen, a <SPAN
CLASS="type"
>ScreenPtr</SPAN
>, and declares a local variable in the
calling function named <TT
CLASS="varname"
>pScreenPriv</TT
>.
<TT
CLASS="function"
>winScreenPriv</TT
> may only be called at the top of a
C function within the variable declaration block; calling the function
elsewhere will break the ANSI C rule that all variables must be
declared at the top of a scope block.  Passing a NULL or invalid
<SPAN
CLASS="type"
>ScreenPtr</SPAN
> to <TT
CLASS="function"
>winScreenPriv</TT
> will
cause an access violation, crashing the Cygwin/XFree86 X Server.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="prog-server-architecture-engines"
>Engine System</A
></H2
><P
>The Cygwin/XFree86 X Server uses several methods of drawing graphics
on the display device; each of these different drawing mehtods is
referred to as an engine.  Each of the engines can be classified as
either a Shadow FB engine, a Native GDI engine, or as a Primary FB
engine.  It should be noted that the Primary FB engine is deprecated
and is discussed here only for completeness.  The engines are
disscussed in the following sections, in order of importance.</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-engines-shadow"
>Shadow FB Engines</A
></H3
><P
>The Shadow FB engines use Keith Packard's <A
HREF="glossary.html#gloss-fb-layer"
><I
CLASS="glossterm"
>FB</I
></A
> drawing procedures wrapped
with his <A
HREF="glossary.html#gloss-shadow-layer"
><I
CLASS="glossterm"
>Shadow</I
></A
>
layer that allows drawing to an <A
HREF="glossary.html#gloss-offscreen-framebuffer"
><I
CLASS="glossterm"
>offscreen
framebuffer</I
></A
> with periodic updates of the <A
HREF="glossary.html#gloss-primary-framebuffer"
><I
CLASS="glossterm"
>primary
framebuffer</I
></A
>.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-engines-native"
>Native GDI
Engine</A
></H3
><P
>The Native GDI engine will eventually translate individual X
graphics calls into their GDI equivalent.  Some X graphics calls do
not translate direclty to a GDI call so they may be passed through the
MI layer to change them into a serious of lower level calls that are
supported.  Currently, the Native GDI engine passes all X graphics
calls through the MI layer to convert them into three functions:
<TT
CLASS="function"
>FillSpans</TT
>, <TT
CLASS="function"
>GetSpans</TT
>, and
<TT
CLASS="function"
>SetSpans</TT
>.  The functionality of those three
functions, as of 2001-10-28, is limited to the functionality needed to
draw the familiar X background pattern upon X Server startup.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-engines-primary"
>Primary FB Engine</A
></H3
><P
>The Primary FB engine is deprecated.  Primary FB works in the
same manner that the original Cygwin/XFree86 X Server worked, namely, it
uses <TT
CLASS="function"
>IDirectDrawSurface_Lock</TT
> to obtain a pointer
to the <A
HREF="glossary.html#gloss-primary-framebuffer"
><I
CLASS="glossterm"
>primary
framebuffer</I
></A
> memory at server startup.  This memory pointer
is held until the X Server shuts down.  This technique does not work
on all versions of Windows.</P
><P
>Locking the primary framebuffer on Windows 95/98/Me causes the
Win16Mutex to be obtained by the program that locks the primary
framebuffer; the Win16Mutex is not released until the primary
framebuffer is unlocked.  The Win16Mutex is a semaphore introduced in
Windows 95 that prevents 16 bit Windows code from being reentered
by different threads or processes.  For compatibility reasons, all GDI
operations in Windows 95/98/Me are written in 16 bit code, thus
requiring that the Win16Mutex be obtained before performing those
operations.  All of this leads to the following situation on Windows
95/98/Me:</P
><OL
TYPE="1"
><LI
><P
>The primary framebuffer is locked, causing the Cygwin/XFree86 X
Server to hold the Win16Mutex.</P
></LI
><LI
><P
>Windows switches the Cygwin/XFree86 X Server out of the current
process slot; another process is switched in.</P
></LI
><LI
><P
>The newly selected process makes a GDI function call.</P
></LI
><LI
><P
>The GDI function call must wait for the Win16Mutex to be
released, but the Win16Mutex cannot be released until the Cygwin/XFree86 X
Server releases the Win16Mutex.  However, the Cygwin/XFree86 X Server will
not release the Win16Mutex until it exits.  The end result is that the
Win16Mutex has been deadlocked and the Windows machine is frozen
with no way to recover.</P
></LI
></OL
><P
>Windows NT/2000/XP do not contain any 16 bit code, so the
Win16Mutex is not an issue; thus, the Primary FB engine works fine on
those operating systems.  However, drawing directly to the primary
framebuffer suffers performance problems.  For example, on some
systems writing to the primary framebuffer requires doing memory reads
and writes across the PCI bus which is only 32 bits wide and features
a clock speed of 33 MHz, as opposed to accessing system memory, which
is attached to a 64 bit wide bus that runs at between 100 and 266
(effective) MHz.  Furthermore, accessing the primary framebuffer
memory requires several synchronization steps that take many clock
cycles to complete.  The end result is that the Primary FB engine is
several times slower than the Shadow FB engines.</P
><P
>The Primary FB engine also has several unique issues that are
difficult to program around.  Development of the Primary FB engine has
ceased, due to the difficulty of maintaining it, coupled with the fact
that Primary FB does not run on Windows 95/98/Me and with the poor
performance of Primary FB.  The Primary FB source code has been left
in place so that future programmers can enable it and see the poor
performance of the engine for themselves.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="prog-server-architecture-input"
>User Input</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-input-keyboard"
>Keyboard</A
></H3
><P
>Foo!</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="prog-server-architecture-input-mouse"
>Mouse</A
></H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="prog-server-architecture-input-mouse-wheel"
>Wheel</A
></H4
><P
>Foo!</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="prog-server-architecture-input-mouse-motion"
>Motion</A
></H4
><P
>Foo!</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="prog-server-architecture-input-mouse-buttons"
>Buttons</A
></H4
><P
>Foo!</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="prog-server-architecture-input-mouse-3be"
>Three Button
Emulation</A
></H4
><P
>Foo!</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"/><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="prog-tree-layout.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="cygwin-xfree-cg.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="prog-obtaining-source.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Source Code Tree Layout</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="programming.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Obtaining the Source Code</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>