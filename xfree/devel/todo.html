<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en-US">

<head>
<title>Cygwin/X - Development - To-Do List</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../xfree86.css">

</head>

<!--#include virtual="../cygx-header.html" -->

<!-- BODY MODIFIED: $Date$ $Author$ -->

<h2>Cygwin/X - Development - To-Do List</h2>

<p>Last updated: 2003-01-07 2315 EST (Harold L Hunt II)</p>

<p>Following is a list of open tasks on the Cygwin/X
project:</p>

<table border="0" cellpadding="5">

<thead>
<tr>
<td><b>Summary</b></td>
<td><b>Updated</b></td>
<td><b>Description</b></td>
</tr>
</thead>


<tbody>

<!-- ToDo item template -->
<!--
<tr valign="top">
<td></td>

<td></td>

<td></td>
</tr>
-->


<tr valign="top">
<td>Emulate PseudoColor on TrueColor</td>

<td>2003-09-23</td>

<td>Provide emulation of PseudoColor visuals (typically 8-bit
palette-based visuals) on top of the default TrueColor visual (when
running in 15, 16, 24, or 32 bit color depths).  This will allow a lot
of CAD-type applications that require PseudoColor to be run when
Windows is in a color mode higher than 8 bits per pixel.  The general
idea here is to add checks to any copying of data between offscreen
and onscreen, as well as between areas on the screen; these checks
test for differing visual types and convert the pixels and colors
accordingly.</td>
</tr>


<tr valign="top">
<td>Window manager detection</td>

<td>2003-09-22</td>

<td>Search for a better mechanism to detect when another window
manager is already running so that the -multiwindow window manager can
abort initialization.  This should result in a failure message.  We
should also be using this mechanism to signal that our window manager
is running so that other window managers started after ours will fail
to initialize.  I saw some documentation on this, possibly in the
ICCCM, and tried to implement what they described, but it does not
appear to be working.</td>
</tr>


<tr valign="top">
<td>MultiWindow DirectDraw and DirectDraw NL</td>

<td>2003-09-22</td>

<td>Try to create one DirectDrawSurface for a single top-level window
in MultiWindow mode.  Ignore window repositioning, etc. for now; just
make the surface paint correctly in MultiWindow mode.  MultiWindow
mode is currently slower than it has to be because it only uses the
ShadowGDI engine.  MultiWindow mode eventually needs to be abstracted
so that it can run on the ShadowDD and ShadowDDNL engines.  All I want
to see right now is a single surface being created for one
window... all the rest can come later.</td>
</tr>


<tr valign="top">
<td>User's Guide - Document .XWinrc</td>

<td>2003-09-22</td>

<td>Documentation needs to be added to the User's Guide for Earle F
Philhower III's .XWinrc mechanism.  The documentation source is
available via CVS in the 'xoncygwin' project on sourceforge.  This
task is greatly simplied by the fact that Earle provided comments in
his <a
href="http://www.msu.edu/~huntharo/xwin/server/example.XWinrc">example
.XWinrc file</a>.</td>
</tr>


<tr valign="top">
<td>DirectDraw windowed PseudoColor</td>

<td>2003-08-27</td>

<td>Figure out a satisfactory solution for enabling DirectDraw engines
to support PseudoColor visuals when running in 8 bit color modes.
DirectDraw reserves the first ten and the last ten colors in each
DirectDrawPalette object when running in windowed mode.  Therefore,
PseudoColor visuals are only supported with DirectDraw engines when
running in fullscreen 8 bit color modes.</td>
</tr>


<tr valign="top">
<td>Windows clipboard integration</td>

<td>2004-01-07</td>

<td>Extend <a href="xwinclip/">xwinclip</a>, the Cygwin/X clipboard
manager, to handle data types other than XA_STRING, COMPOUND_TEXT, and
UTF8_STRING; for example, BITMAP, PIXMAP, etc.</td>
</tr>


<tr valign="top">
<td>Windows display mode change while running</td>

<td>2003-08-27</td>

<td>Catch and gracefully handle display mode changes while
Cygwin/X is running.  Some of this will require using
server-side RandR (resize and rotate extension) while other parts will
require catching window message and shuffling around device context
handles, reacquiring DirectDraw surfaces, etc.  Example case: assuming
a notebook computer that has an internal 1024x768 display and an
external 1280x1024 monitor; start Cygwin/X when the external
monitor is plugged in, thus the Windows desktop size will be 1280x1024
and the primary display is the external monitor; unplug the external
display so that the notebook reverts to its internal display; the
display area will have changed from 1280x1024 to 1024x768, and the
device context and/or DirectDraw surface handles may need to be
changed to point to the internal display.  Currently switching from
the monitor to the internal display will cause the Cygwin/X
window to cease refreshing; the window will only be filled with white.
Switching from the internal display to the external monitor shows the
Cygwin/X window with the content stretched to fit the now larger
window.</td>
</tr>

</tbody>
</table>

<!--#include virtual="../cygx-footer.html" -->

</body>
</html>
