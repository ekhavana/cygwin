<html>
<HEAD>
<title>Documentation on the dl family of calls</title>
</HEAD>

<body bg properties="fixed" bgcolor="#ffffff" link="#b07008"
vlink="#000000">

<H1>Documentation on the dl family of calls</H1>
<H2>Introduction</H2>

The implementation of dlopen, dlclose, dlsym, and dlerror allow '.dll's
to have almost the same behavior as '.so' on UNIX:

<ul>
<li>link dll = dll automatically loaded (i.e. exe has linked with import lib)
<li>open dll = dll opened with dlopen
</ul>

<H2>Description:</H2>

<ul>
<li> Implementation of dlopen, dlcose, dlsym, dlerror

<li> When loaded link and open dlls are correctly initialized,
	global constructors are called.

<li> When dll is detached (exit for link dll or dlclose for open dll),
	the global destructors are called.

<li> When process is forked:
<ul>
<li> Data of link dlls are correctly copied in child process and
  the global destructors are called when child is terminated.
<li> Two cases for open dlls:
<ul>
<li> Reload is allowed (dlfork (FORK_RELOAD): see below).
		In this case, loaded dlls are reloaded in child process,
		data are correctly copied from parent to the child,
		and handles opened in the
		parent process are accessible in the child.
		(WARNING: to have this functionality the dlls MUST be
		loaded with dlopen and not with LoadLibrary).

<li> Reload is disallowed (default).  In this case child can't access
               open dlls of parent.
</ul>
</ul>
</ul>

This functionality depends on the hypothesis that in a forked process
the dlls will be mapped at the same addresses as in the parent if they are
loaded in same order.

<H2>How to use it:</H2>

In your dll code you must <P>

1) <tt>#include &#60;cygwin/cygwin_dll.h&#62;</tt> <P>

	then use the declaration macro: <P>
		
	<tt>DECLARE_CYGWIN_DLL(&#60;your entry point&#62;);</tt><P>

Note that the fixup to terminate import section is included in macro. <P>

2) In the link phase use <tt>"__cygwin_dll_entry@12"</tt> as entry point.
Note that you may have to perform 3 link passes. <P>

3) dlfork is a new Cygwin-specific function.  Its prototype is in
	dlfcn.h.  dlfork takes an int as an argument which can have the
	following values: <P>

<ul>
	<li><tt>FORK_NO_RELOAD</tt>: this is the default behavior, the child
		process won't reload open libraries of parent, and so can't
		access to parent's handles.

	<li><tt>FORK_RELOAD</tt>: the child process will reload all
	open dlls and can access parent's handles (lib or functions).
	This should be used only if necessary, because it may be
	slower.
</ul>

	The dlfork flag is a global variable which is not inherited by child
	process. (I.e. a forked process begins always with
	<tt>FORK_NO_RELOAD</tt>).

</body>
</html>
