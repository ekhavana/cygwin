<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Special filenames</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Cygwin User's Guide"
HREF="cygwin-ug-net.html"><LINK
REL="UP"
TITLE="Using Cygwin"
HREF="using.html"><LINK
REL="PREVIOUS"
TITLE="File permissions"
HREF="using-filemodes.html"><LINK
REL="NEXT"
TITLE="The CYGWIN environment
variable"
HREF="using-cygwinenv.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Cygwin User's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="using-filemodes.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Using Cygwin</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="using-cygwinenv.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="USING-SPECIALNAMES"
></A
>Special filenames</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN600"
></A
>DOS devices</H2
><P
>Windows filenames invalid under Windows are also invalid under
Cygwin.  This means that base filenames such as 
<TT
CLASS="FILENAME"
>AUX</TT
>, <TT
CLASS="FILENAME"
>COM1</TT
>,
<TT
CLASS="FILENAME"
>LPT1</TT
> or <TT
CLASS="FILENAME"
>PRN</TT
> (to name a few)
cannot be used in a regular Cygwin Windows or POSIX path, even with an
extension (<TT
CLASS="FILENAME"
>prn.txt</TT
>). However the special names can be
used as filename extensions (<TT
CLASS="FILENAME"
>file.aux</TT
>). You can use
the special names as you would under DOS, for example you can print on your
default printer with the command <B
CLASS="COMMAND"
>cat filename &#62; PRN</B
>
(make sure to end with a Form Feed).</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN610"
></A
>POSIX devices</H2
><P
>There is no need to create a POSIX <TT
CLASS="FILENAME"
>/dev</TT
> 
directory as it is simulated within Cygwin automatically.
It supports the following devices: <TT
CLASS="FILENAME"
>/dev/null</TT
>,
<TT
CLASS="FILENAME"
>/dev/zero</TT
>, <TT
CLASS="FILENAME"
>/dev/tty</TT
>,
<TT
CLASS="FILENAME"
>/dev/ttyX</TT
>, <TT
CLASS="FILENAME"
>/dev/ptmx</TT
>,
<TT
CLASS="FILENAME"
>/dev/comX</TT
> (the serial ports),
<TT
CLASS="FILENAME"
>/dev/windows</TT
> (the windows message queue),
<TT
CLASS="FILENAME"
>/dev/random</TT
> and <TT
CLASS="FILENAME"
>/dev/urandom</TT
>.
These devices cannot be seen with the command <B
CLASS="COMMAND"
>ls /dev</B
>
although commands such as <B
CLASS="COMMAND"
>ls /dev/tty</B
> work fine.</P
><P
>Windows NT/W2K/XP additionally support raw devices like floppies,
disks, partitions and tapes.  These are accessed from Cygwin applications
using POSIX device names which are supported in two different ways.
Up to 1.3.3, Cygwin only uses Win32 device names, since 1.3.4
it additionally uses NT internal device names.</P
><P
>Up to Cygwin 1.3.3 the only way to access those devices is
to mount the Win32 device names to a POSIX device name.</P
><P
>The Win32 device name for a partition is the drive letter
with leading <TT
CLASS="FILENAME"
>\\.\</TT
>, so the floppy would be
<TT
CLASS="FILENAME"
>\\.\A:</TT
>, the first partition typically
<TT
CLASS="FILENAME"
>\\.\C:</TT
>. Complete drives (except floppies and CD-ROMS
which are supported as partitions only) are named
<TT
CLASS="FILENAME"
>\\.\PHYSICALDRIVEx</TT
>. The <TT
CLASS="LITERAL"
>x</TT
>
is the drive number which you can check in the disk manager.
Each drive line has prepended the text "Disk x".</P
><P
>To access tape drives the Win32 file name <TT
CLASS="FILENAME"
>\\.\TAPEx</TT
>
is used. For example the first installed tape device is named
<TT
CLASS="FILENAME"
>\\.\tape0</TT
>.</P
><P
>The naming convention is simple: The name of the POSIX device has to begin with
<TT
CLASS="FILENAME"
>/dev/</TT
> and the rest is as you like. The only
exception are tape devices. To identify if the tape device is
used as a rewind or a no-rewind device the name must not begin with
<TT
CLASS="LITERAL"
>n</TT
> (rewind) or has to begin with <TT
CLASS="LITERAL"
>n</TT
>
(no-rewind).</P
><P
>Some examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>mount -b //./A: /dev/fd0              # mount floppy as raw block special
mount -b //./physicaldrive1 /dev/hdb  # mount "Disk 1"
mount -b //./tape0 /dev/st0           # mount first tape as the rewind device...
mount -b //./tape0 /dev/nst0          # ...and as the no-rewind device</PRE
></TD
></TR
></TABLE
><P
>Note the usage of the <TT
CLASS="LITERAL"
>-b</TT
> option. It is best to
include the -b option when mounting these devices to ensure that all
file I/O is in "binary mode".</P
><P
>Since Cygwin 1.3.4 raw devices are accessible from inside of Cygwin processes
using fixed POSIX device names.  That means, you don't have to mount the devices
anymore which results in a more cleaner mount table.</P
><P
>These new fixed POSIX device names are generated using a direct conversion
from the POSIX namespace to the internal NT namespace.
E.g. the first harddisk is the NT internal device \device\harddisk0\partition0
or the first partition on the third harddisk is \device\harddisk2\partition1.
The first floppy in the system is \device\floppy0, the first CD-ROM is
\device\cdrom0 and the first tape drive is \device\tape0.</P
><P
>The new fixed POSIX names are mapped to NT internal devices as
follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>/dev/st0	\device\tape0, rewind
/dev/nst0	\device\tape0, no-rewind
/dev/st1	\device\tape1
...

/dev/fd0	\device\floppy0
/dev/fd1	\device\floppy1
...

/dev/scd0	\device\cdrom0
/dev/scd1	\device\cdrom1
...

/dev/sda	\device\harddisk0\partition0	(whole disk)
/dev/sda1	\device\harddisk0\partition1	(first partition)
...
/dev/sda15	\device\harddisk0\partition15	(fifteenth partition)

/dev/sdb	\device\harddisk1\partition0
/dev/sdb1	\device\harddisk1\partition1

[up to]

/dev/sdl	\device\harddisk11\partition0
/dev/sdl1	\device\harddisk11\partition1
...
/dev/sdl15	\device\harddisk11\partition15</PRE
></TD
></TR
></TABLE
><P
>if you don't like these device names, feel free to create symbolic
links as they are created on Linux systems for convenience:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>ln -s /dev/scd0 /dev/cdrom
ln -s /dev/st0  /dev/tape
...</PRE
></TD
></TR
></TABLE
><P
>Note that you can't use the mount table to map from fixed device name
to your own device name or to map from internal NT device name to
your own device name.  The following two examples will not work:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>mount -s -f -b /dev/st0 /dev/tape
mount -s -f -b /device/tape0 /dev/tape</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN652"
></A
>The .exe extension</H2
><P
> Executable program filenames end with .exe but the .exe need
not be included in the command, so that traditional UNIX names can be
used.  However, for programs that end in ".bat" and ".com", you cannot
omit the extension.</P
><P
>As a side effect, the <B
CLASS="COMMAND"
> ls filename</B
> gives
information about <TT
CLASS="FILENAME"
>filename.exe</TT
> if
<TT
CLASS="FILENAME"
>filename.exe</TT
> exists and <TT
CLASS="FILENAME"
>filename</TT
>
does not.  In the same situation the function call
<TT
CLASS="FUNCTION"
>stat("filename",..)</TT
> gives information about
<TT
CLASS="FILENAME"
>filename.exe</TT
>.  The two files can be distinguished
by examining their inodes, as demonstrated below.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>C:\&#62;</TT
> <TT
CLASS="USERINPUT"
><B
>ls * </B
></TT
>
a      a.exe     b.exe
<TT
CLASS="PROMPT"
>C:\&#62;</TT
> <TT
CLASS="USERINPUT"
><B
>ls -i a a.exe</B
></TT
>
445885548 a       435996602 a.exe
<TT
CLASS="PROMPT"
>C:\&#62;</TT
> <TT
CLASS="USERINPUT"
><B
>ls -i b b.exe</B
></TT
>
432961010 b       432961010 b.exe</PRE
></TD
></TR
></TABLE
>
If a shell script <TT
CLASS="FILENAME"
>myprog</TT
> and a program
<TT
CLASS="FILENAME"
>myprog.exe</TT
> coexist in a directory, the program
has precedence and is selected for execution of
<B
CLASS="COMMAND"
>myprog</B
>.</P
><P
>The <B
CLASS="COMMAND"
>gcc</B
> compiler produces an executable named
<TT
CLASS="FILENAME"
>filename.exe</TT
> when asked to produce
<TT
CLASS="FILENAME"
>filename</TT
>. This allows many makefiles written
for UNIX systems to work well under Cygwin.</P
><P
>Unfortunately, the <B
CLASS="COMMAND"
>install</B
> and
<B
CLASS="COMMAND"
>strip</B
> commands do distinguish between
<TT
CLASS="FILENAME"
>filename</TT
> and <TT
CLASS="FILENAME"
>filename.exe</TT
>. They
fail when working on a non-existing <TT
CLASS="FILENAME"
>filename</TT
> even if
<TT
CLASS="FILENAME"
>filename.exe</TT
> exists, thus breaking some makefiles.
This problem can be solved by writing <B
CLASS="COMMAND"
>install</B
> and
<B
CLASS="COMMAND"
>strip</B
> shell scripts to provide the extension ".exe"
when needed.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN685"
></A
>The @pathnames</H2
><P
>To circumvent the limitations on shell line length in the native
Windows command shells, Cygwin programs expand their arguments
starting with "@" in a special way.  If a file
<TT
CLASS="FILENAME"
>pathname</TT
> exists, the argument
<TT
CLASS="FILENAME"
>@pathname</TT
> expands recursively to the content of
<TT
CLASS="FILENAME"
>pathname</TT
>. Double quotes can be used inside the
file to delimit strings containing blank space. 
Embedded double quotes must be repeated.
In the following example compare the behaviors of the bash built-in
<B
CLASS="COMMAND"
>echo</B
> and of the program <B
CLASS="COMMAND"
>/bin/echo</B
>.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN693"
></A
><P
><B
>Example 2.  Using @pathname</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>bash$</TT
> <TT
CLASS="USERINPUT"
><B
>echo  'This   is   "a     long"  line' &#62; mylist</B
></TT
>
<TT
CLASS="PROMPT"
>bash$</TT
> <TT
CLASS="USERINPUT"
><B
>echo @mylist</B
></TT
>
@mylist
<TT
CLASS="PROMPT"
>bash$</TT
> <TT
CLASS="USERINPUT"
><B
>/bin/echo @mylist</B
></TT
>
This is a     long line
<TT
CLASS="PROMPT"
>bash$</TT
> <TT
CLASS="USERINPUT"
><B
>rm mylist</B
></TT
>
<TT
CLASS="PROMPT"
>bash$</TT
> <TT
CLASS="USERINPUT"
><B
>/bin/echo @mylist</B
></TT
>
@mylist</PRE
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="using-filemodes.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="cygwin-ug-net.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="using-cygwinenv.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File permissions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="using.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The <TT
CLASS="ENVAR"
>CYGWIN</TT
> environment
variable</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>