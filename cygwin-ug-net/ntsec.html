<HTML
><HEAD
><TITLE
>NT security and the ntsec usage</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="Cygwin User's Guide"
HREF="cygwin-ug-net.html"><LINK
REL="UP"
TITLE="Setting Up Cygwin"
HREF="setup-net.html"><LINK
REL="PREVIOUS"
TITLE="Environment Variables"
HREF="setup-env.html"><LINK
REL="NEXT"
TITLE="Customizing bash"
HREF="setup-files.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Cygwin User's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="setup-env.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Setting Up Cygwin</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="setup-files.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="NTSEC"
>NT security and the <TT
CLASS="LITERAL"
>ntsec</TT
> usage</A
></H1
><P
>The design goal of the ntsec patch was to get a more UNIX like
permission structure based upon the security features of Windows NT.
To describe the changes, I will give a short overview of NT security
in chapter one.</P
><P
>Chapter two discusses the changes in ntsec related to privileges on
processes.</P
><P
>Chapter three shows the basics of UNIX like setting of
file permissions.</P
><P
>Chapter four talks about the advanced settings introduced in
release 1.1</P
><P
>Chapter five illustrates the permission mapping leak of Windows NT.</P
><P
>Chapter six describes the new support of a setuid concept introduced
with release 1.1.3.</P
><P
>Chapter six describes in short the new acl API since release 1.1</P
><P
>The setting of UNIX like object permissions is controlled by the new
<TT
CLASS="ENVAR"
>CYGWIN</TT
> variable setting <TT
CLASS="LITERAL"
>(no)ntsec</TT
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-COMMON"
>NT security</A
></H2
><P
>The NT security allows a process to allow or deny access of
different kind to `objects'. `Objects' are files, processes,
threads, semaphores, etc.</P
><P
>The main data structure of NT security is the `security descriptor'
(SD) structure. It explains the permissions, that are granted (or denied)
to an object and contains information, that is related to so called
`security identifiers' (SID).</P
><P
>A SID is a unique identifier for users, groups and domains. 
SIDs are comparable to UNIX UIDs and GIDs, but are more complicated
because they are unique across networks. Example:</P
><P
>SID of a system `foo':</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  S-1-5-21-165875785-1005667432-441284377</PRE
></TD
></TR
></TABLE
><P
>SID of a user `johndoe' of the system `foo':</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  S-1-5-21-165875785-1005667432-441284377-1023</PRE
></TD
></TR
></TABLE
><P
>The above example shows the convention for printing SIDs. The leading
`S' should show that it is a SID. The next number is a version number which
is always 1. The next number is the so called `top-level authority' that
identifies the source that issued the SID.</P
><P
>While each system in a NT network has it's own SID, the situation
is modified in NT domains: The SID of the domain controller is the
base SID for each domain user. If an NT user has one account as domain
user and another account on his local machine, this accounts are under
any circumstances DIFFERENT, regardless of the usage of the same user
name and password!</P
><P
>SID of a domain `bar':</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  S-1-5-21-186985262-1144665072-740312968</PRE
></TD
></TR
></TABLE
><P
>SID of a user `johndoe' in the domain `bar':</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  S-1-5-21-186985262-1144665072-740312968-1207</PRE
></TD
></TR
></TABLE
><P
>The last part of the SID, the so called `relative identifier' (RID),
is by default used as UID and/or GID under cygwin. As the name and the
above example implies, this id is unique only relative to one system or
domain.</P
><P
>Note, that it's possible, that an user has the same RID on two
different systems. The resulting SIDs are nevertheless different, so
the SIDs are representing different users in an NT network.</P
><P
>There is a big difference between UNIX IDs and NT SIDs, the existence of
the so called `well known groups'. For example UNIX has no GID for the
group of `all users'. NT has an SID for them, called `Everyone' in the
English versions. The SIDs of well-known groups are not unique across
an NT network but their meanings are unmistakable.
Examples of well-known groups:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>everyone                        S-1-1-0
creator/owner                   S-1-3-0
batch process (via `at')        S-1-5-3
authenticated users             S-1-5-11
system                          S-1-5-18</PRE
></TD
></TR
></TABLE
><P
>The last important group of SIDs are the `predefined groups'. This
groups are used mainly on systems outside of domains to simplify the 
administration of user permissions. The corresponding SIDs are not unique
across the network so they are interpreted only locally:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>administrators                  S-1-5-32-544
users                           S-1-5-32-545
guests                          S-1-5-32-546
...</PRE
></TD
></TR
></TABLE
><P
>Now, how are permissions given to objects? A process may assign an SD
to the object. The SD of an object consists of three parts:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>the SID of the owner </P
></LI
><LI
><P
>the SID of the group </P
></LI
><LI
><P
>a list of SIDs with their permissions, called
`access control list' (ACL) </P
></LI
></UL
><P
>UNIX is able to create three different permissions, the permissions
for the owner, for the group and for the world. In contrast the ACL
has a potentially infinite number of members. Every member is a so called
`access control element' (ACE). An ACE contains three parts:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>the type of the ACE </P
></LI
><LI
><P
>permissions, described with a DWORD </P
></LI
><LI
><P
>the SID, for which the above mentioned permissions are
set </P
></LI
></UL
><P
>The two important types of ACEs are the `access allowed ACE' and the
`access denied ACE'. The ntsec patch only used `access allowed ACEs' up
to Cygwin version 1.1.0. Later versions use `access denied ACEs' as well
to reflect the UNIX permissions as good as possible.</P
><P
>The possible permissions on objects are more detailed than in
UNIX. For example, the permission to delete an object is different
from the write permission.</P
><P
>With the aforementioned method NT is able to grant or revoke permissions
to objects in a far more specific way. But what about cygwin? In a POSIX
environment it would be fine to have the security behavior of a POSIX
system. The NT security model is MOSTLY able to reproduce the POSIX model.
The ntsec patch tries to do this in cygwin.</P
><P
>You ask "Mostly? Why mostly???" Because there's a leak in the NT model.
I will describe that in detail in chapter 4.</P
><P
>Creating  explicit object security is not that easy so you will often
see only two simple variations in use:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>default permissions, computed by the operating system </P
></LI
><LI
><P
>each permission to everyone </P
></LI
></UL
><P
>For parameters to functions that create or open securable objects another
data structure is used, the `security attributes' (SA). This structure
contains an SD and a flag that specifies whether the returned handle
to the object is inherited to child processes or not.
This property is not important for the ntsec patch description so in
this document the difference between SDs and SAs is ignored.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-PROCESSES"
>Process privileges</A
></H2
><P
>Any process started under control of cygwin has a semaphore attached
to it, that is used for signaling purposes. The creation of this semaphore
can be found in sigproc.cc, function `getsem'. The first parameter to the
function call `CreateSemaphore' is an SA. Without ntsec patch this SA 
assigns default security to the semaphore. There is a simple disadvantage:
Only the owner of the process may send signals to it. Or, in other words,
if the owner of the process is not a member of the administrators' group,
no administrator may kill the process! This is especially annoying, if
processes are started via service manager.</P
><P
>The ntsec patch now assigns an SA to the process control semaphore, that
has each permission set for the user of the process, for the
administrators' group and for `system', which is a synonym for the
operating system itself. The creation of this SA is done by the function
`sec_user', that can be found in `shared.cc'. Each member of the
administrators' group is now allowed to send signals to any process
created in cygwin, regardless of the process owner.</P
><P
>Moreover, each process now has the appropriate security settings, when
it is started via `CreateProcess'. You will find this in function
`spawn_guts' in module `spawn.cc'. The security settings for starting a
process in another user context have to add the sid of the new user, too.
In the case of the `CreateProcessAsUser' call, sec_user creates an SA with
an additional entry for the sid of the new user.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-FILES"
>File permissions</A
></H2
><P
>If ntsec is turned on, file permissions are set as in UNIX. An SD is
assigned to the file containing the owner and group and ACEs for the
owner, the group and `Everyone'.</P
><P
>The complete settings of UNIX like permissions can be found in the file
`security.cc'. The two functions `get_nt_attribute' and `set_nt_attribute'
are the main code. The reading and writing of the SDs is done by the
functions `read_sd' and `write_sd'. `write_sd' uses the function `BackupRead'
instead of the simpler function `SetFileSecurity' because the latter is
unable to set owners different from the caller.</P
><P
>If you are creating a file `foo' outside of cygwin, you will see something
like the following on <B
CLASS="COMMAND"
>ls -ln</B
>:</P
><P
>If your login is member of the administrators' group:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  rwxrwxrwx 1  544  513  ... foo</PRE
></TD
></TR
></TABLE
><P
>if not:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  rwxrwxrwx 1  1000  513  ... foo</PRE
></TD
></TR
></TABLE
><P
>Note the user and group IDs. 544 is the UID of the administrators' group.
This is a `feature' <TT
CLASS="LITERAL"
>:-P</TT
> of WinNT. If one is a member of
the administrators' group, every file, that he has created is owned by the
administrators' group, instead by him.</P
><P
>The second example shows the UID of the first user, that has been
created with NT's the user administration tool. The users and groups are
sequentially numbered, starting with 1000. Users and groups are using the
same numbering scheme, so a user and a group don't share the same ID.</P
><P
>In both examples the GID 513 is of special interest. This GID is a
well known group with different naming in local systems and domains.
Outside of domains the group is named 'None' (`Kein' in German, `Aucun'
in French, etc.), in domains it is named 'Domain Users'.  Unfortunately,
the group `None' is never shown in the user admin tool outside of domains!
This is very confusing but it seems that this has no negativ influences.</P
><P
>To work correctly the ntsec patch depends on reasoned files
<TT
CLASS="FILENAME"
>/etc/passwd/</TT
> and <TT
CLASS="FILENAME"
>/etc/group</TT
>.
In cygwin release 1.0 the names and the IDs must correspond to the
appropriate NT IDs! The IDs used in cygwin are the RID of the NT SID, as
mentioned earlier.
An SID of e.g. the user `corinna' on my NT workstation:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  S-1-5-21-165875785-1005667432-441284377-1000</PRE
></TD
></TR
></TABLE
><P
>Note the last number: It's the RID 1000, the cygwin's UID.</P
><P
>Unfortunately, workstations and servers outside of domains are not
able to set primary groups! In these cases, where there is no correlation
of users to primary groups, NT returns 513 (None) as primary group,
regardless of the membership to existing local groups.</P
><P
>When using <B
CLASS="COMMAND"
>mkpasswd  -l -g</B
> on such systems, you
have to change the primary group by hand if `None' as primary group is
not what you want (and I'm sure, it's not what you want!)</P
><P
>Look at the following examples, which were parts of my files before
storing SIDs in /etc/passwd and /etc/group has been introduced (See next
chapter for details).  With the exception of my personal user entry, all
entries are well known entries.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN235"
></A
><P
><B
>Example 2-1. /etc/passwd</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>everyone:*:0:0:::
system:*:18:18:::
administrator::500:544::/home/root:/bin/bash
guest:*:501:546:::
administrators:*:544:544::/home/root:
corinna::1000:547:Corinna Vinschen:/home/corinna:/bin/tcsh</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN238"
></A
><P
><B
>Example 2-2. /etc/group</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>everyone::0:
system::18:
none::513:
administrators::544:
users::545:
guests::546:
powerusers::547:</PRE
></TD
></TR
></TABLE
></DIV
><P
>As you can see I've changed my primary group membership from 513 (None)
to 547 (powerusers).  So all file I created inside of Cygwin were now owned
by the powerusers group instead of None.  This is the way I liked it.</P
><P
></P
><P
>Groups may be mentioned in the passwd file, too. This has two
advantages:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>Because NT assigns them to files as owners, a
<B
CLASS="COMMAND"
>ls -l</B
> is often better readable.</P
></LI
><LI
><P
>Moreover it's possible to assigned them to files as
owners with cygwin's <B
CLASS="COMMAND"
>chown</B
>.</P
></LI
></UL
><P
>The group `system' is the aforementioned synonym for the operating system
itself and is normally the owner of processes, that are started through
service manager. The same is true for files, that are created by
processes, which are started through service manager.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-RELEASE1.1"
>New since Cygwin release 1.1</A
></H2
><P
>In Cygwin release 1.1 a new technique of using the 
<TT
CLASS="FILENAME"
>/etc/passwd</TT
> and <TT
CLASS="FILENAME"
>/etc/group</TT
>
 is introduced.</P
><P
>Both files may now contain SIDs of users and groups. They
are saved in the last field of pw_gecos in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>
and in the gr_passwd field in <TT
CLASS="FILENAME"
>/etc/group</TT
>.</P
><P
>This has the following advantages:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>ntsec works better in domain environments.</P
></LI
><LI
><P
>Accounts (users and groups) may get another name in
cygwin than their NT account name. The name in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>
or <TT
CLASS="FILENAME"
>/etc/group</TT
> is transparently used by cygwin
applications (eg. <B
CLASS="COMMAND"
>chown</B
>, <B
CLASS="COMMAND"
>chmod</B
>,
<B
CLASS="COMMAND"
>ls</B
>):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root::500:513::/home/root:/bin/sh</PRE
></TD
></TR
></TABLE
><P
>instead of</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>adminstrator::500:513::/home/root:/bin/sh</PRE
></TD
></TR
></TABLE
><P
>Caution: If you like to use the account as login account via
<B
CLASS="COMMAND"
>telnet</B
> etc. you have to remain the name unchanged or
you have to use the special version of <B
CLASS="COMMAND"
>login</B
> which is
part of the standard Cygwin distribution since 1.1.</P
></LI
><LI
><P
>Cygwin UIDs and GIDs are now not necessarily the RID
part of the NT SID:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root::0:513:S-1-5-21-54355234-56236534-345635656-500:/home/root:/bin/sh</PRE
></TD
></TR
></TABLE
><P
>instead of</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root::500:513::/home/root:/bin/sh</PRE
></TD
></TR
></TABLE
></LI
><LI
><P
>As in U*X systems UIDs and GIDs numbering scheme now
don't influence each other. So it's possible to have same Id's for a
user and a group:</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN284"
></A
><P
><B
>Example 2-3. /etc/passwd:</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root::0:0:S-1-5-21-54355234-56236534-345635656-500:/home/root:/bin/sh</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN287"
></A
><P
><B
>Example 2-4. /etc/group:</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root:S-1-5-32-544:0:</PRE
></TD
></TR
></TABLE
></DIV
></LI
></UL
><P
>The tools <B
CLASS="COMMAND"
>mkpasswd</B
> and <B
CLASS="COMMAND"
>mkgroup</B
>
create the needed entries by default. If you don't want that you can use
the options <TT
CLASS="LITERAL"
>-s</TT
> or <TT
CLASS="LITERAL"
>--no-sids</TT
>. I suggest
not to do this since ntsec works better when having the SIDs available.</P
><P
>Please note that the pw_gecos field in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>
is defined as a comma seperated list. The SID has to be the last field!</P
><P
>As aforementioned you are able to use cygwin account names different
from the NT account names. If you want to login thru `telnet' or something
else you have to use the special <B
CLASS="COMMAND"
>login</B
>. You may then
add another field to pw_gecos which contains the NT user name including
it's domain. So you are able to login as each domain user. The syntax
is easy: Just add an entry of the form U-ntdomain\ntusername to the pw_gecos
field. Note that the SID must still remain the last field in pw_gecos!</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>the_king::1:1:Elvis Presley,U-STILLHERE\elvis,S-1-5-21-1234-5678-9012-1000:/bin/sh</PRE
></TD
></TR
></TABLE
><P
>For a local user just drop the domain:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>the_king::1:1:Elvis Presley,U-elvis,S-1-5-21-1234-5678-9012-1000:/bin/sh</PRE
></TD
></TR
></TABLE
><P
>In either case the password of the user is taken from the NT user
database, NOT from the passwd file!</P
><P
>As in the previous chapter I give my personal
<TT
CLASS="FILENAME"
>/etc/passwd</TT
> and <TT
CLASS="FILENAME"
>/etc/group</TT
> as
examples.  Please note that I've changed these files heavily!  There's no
need to change them that way, it's just for testing purposes and...
for fun.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN306"
></A
><P
><B
>Example 2-5. /etc/passwd</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root:*:0:0:Administrators group,S-1-5-32-544::
Everyone:*:1:1:,S-1-1-0::
SYSTEM:*:18:18:,S-1-5-18:/home/system:/bin/bash
admin:*:500:513:,S-1-5-21-1844237615-436374069-1060284298-500:/home/Administrator:/bin/bash
corinna:*:100:0:Corinna Vinschen,S-1-5-21-1844237615-436374069-1060284298-1003:/home/corinna:/bin/tcsh
Guest:*:501:546:,S-1-5-21-1844237615-436374069-1060284298-501:/home/Guest:/bin/bash</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN309"
></A
><P
><B
>Example 2-6. /etc/group</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>root:S-1-5-32-544:0:
everyone:S-1-1-0:1:
local:S-1-2-0:2:
network:S-1-5-2:3:
interactive:S-1-5-4:4:
authenticatedusers:S-1-5-11:5:
SYSTEM:S-1-5-18:18:
local_svc:S-1-5-19:19:
netwrk_svc:S-1-5-20:20:
none:S-1-5-21-1844237615-436374069-1060284298-513:513:
bckup_op:S-1-5-32-551:551:
guests:S-1-5-32-546:546:
pwrusers:S-1-5-32-547:547:
replicator:S-1-5-32-552:552:
users:S-1-5-32-545:545:</PRE
></TD
></TR
></TABLE
></DIV
><P
>If you want to do similar changes to your files, please do that only
if you're feeling comfortably with the concepts.  Otherwise don't be surprised
if some stuff doesn't work anymore.  If you screwed up things, revert to files
created by mkpasswd and mkgroup.  Especially don't change the uid or the name
of user SYSTEM.  Even if that works mostly, some Cygwin applications running
as local service under that account could behave strangly suddenly.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-MAPPING"
>The mapping leak</A
></H2
><P
>Now its time to point out the leak in the NT permissions.
The official documentation explains in short the following:</P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>access allow ACEs are accumulated regarding to the
group membership of the caller.</P
></LI
><LI
><P
>The order of ACEs is important. The system reads them
in sequence until either any needed right is denied or all needed rights
are granted. Later ACEs are then not taken into account.</P
></LI
><LI
><P
>All access denied ACEs _should_ precede any
access allowed ACE.</P
></LI
></UL
><P
>Note that the last rule is a preference, not a law. NT will correctly
deal with the ACL regardless of the sequence order. The second rule is
not modified to get the ACEs in the prefered order.</P
><P
>Unfortunately the security tab of the NT4 explorer is completely
unable to deal with access denied ACEs while the explorer of W2K rearranges
the order of the ACEs before you can read them. Thank God, the sort order
remains unchanged if one presses the Cancel button.</P
><P
>You still ask "Where is the leak?" NT ACLs are unable to reflect each
possible combination of POSIX permissions. Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>rw-r-xrw-</PRE
></TD
></TR
></TABLE
><P
>1st try:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>UserAllow:   110
GroupAllow:  101
OthersAllow: 110</PRE
></TD
></TR
></TABLE
><P
>Hmm, because of the accumulation of allow rights the user may
execute because the group may execute.</P
><P
>2st try:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>UserDeny:    001
GroupAllow:  101
OthersAllow: 110</PRE
></TD
></TR
></TABLE
><P
>Now the user may read and write but not execute. Better? No!
Unfortunately the group may write now because others may write.</P
><P
>3rd try:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>UserDeny:    001
GroupDeny:   010
GroupAllow:  001
OthersAllow: 110</PRE
></TD
></TR
></TABLE
><P
>Now the group may not write as intended but unfortunately the user may
not write anymore, too. How should this problem be solved? According to
the official rules a UserAllow has to follow the GroupDeny but it's
easy to see that this can never be solved that way.</P
><P
>The only chance:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>UserDeny:    001
UserAllow:   010
GroupDeny:   010
GroupAllow:  001
OthersAllow: 110</PRE
></TD
></TR
></TABLE
><P
>Again: This works for both, NT4 and W2K. Only the GUIs aren't
able to deal with that order.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-ACLFUNCS"
>New acl API</A
></H2
><P
>For dealing with ACLs Cygwin now has the acl API as it's
implemented in newer versions of Solaris. The new data structure
for a single ACL entry (ACE in NT terminology) is defined in
<TT
CLASS="FILENAME"
>sys/acl.h</TT
> as:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>typedef struct acl {
  int     a_type;  /* entry type */
  uid_t   a_id;    /* UID | GID */
  mode_t  a_perm;  /* permissions */
} aclent_t;</PRE
></TD
></TR
></TABLE
><P
>The a_perm member of the aclent_t type contains only the bits
for read, write and execute as in the file mode. If eg. read permission
is granted, all read bits (S_IRUSR, S_IRGRP, S_IROTH) are set.
CLASS_OBJ or MASK ACL entries are not fully implemented yet.</P
><P
>The new API calls are</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>acl(2), facl(2)
aclcheck(3),
aclsort(3),
acltomode(3), aclfrommode(3),
acltopbits(3), aclfrompbits(3),
acltotext(3), aclfromtext(3)</PRE
></TD
></TR
></TABLE
><P
>Like in Solaris, Cygwin has two new commands for working with
ACLs on the command line: <B
CLASS="COMMAND"
>getfacl</B
> and
<B
CLASS="COMMAND"
>setfacl</B
>.</P
><P
>Online man pages for the aforementioned commands and API calls
can be found on eg. http://docs.sun.com</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NTSEC-SETUID"
>New setuid concept</A
></H2
><P
>UNIX applications which have to switch the user context are using
the <B
CLASS="COMMAND"
>setuid</B
> and <B
CLASS="COMMAND"
>seteuid</B
> calls which
are not part of the Windows API.
Nevertheless these calls are supported under Windows NT/W2K since Cygwin
release 1.1.3.  Because of the nature of NT security an application which
needs the ability has to be patched, though.</P
><P
>NT uses so called `access tokens' to identify a user and it's
permissions. To switch the user context the application has to request
such an `access token'. This is typically done by calling the NT API
function <B
CLASS="COMMAND"
>LogonUser</B
>. The access token is returned and
either used in <B
CLASS="COMMAND"
>ImpersonateLoggedOnUser</B
> to change user
context of the current process or in <B
CLASS="COMMAND"
>CreateProcessAsUser</B
>
to change user context of a spawned child process. An important restriction
is that the application using <B
CLASS="COMMAND"
>LogonUser</B
> must have special
permissions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>"Act as part of the operating system"
"Replace process level token"
"Increase quotas"</PRE
></TD
></TR
></TABLE
><P
>Note that administrators do not have all that user rights set by default.</P
><P
>Two new Cygwin calls are introduced to support porting
<B
CLASS="COMMAND"
>setuid</B
> applications with a minimum of effort. You only
have to care to give Cygwin the right access token and then you can call
<B
CLASS="COMMAND"
>seteuid</B
> or <B
CLASS="COMMAND"
>setuid</B
> as usual in POSIX
applications. The call to <B
CLASS="COMMAND"
>sexec</B
> is not needed
anymore. Porting a <B
CLASS="COMMAND"
>setuid</B
> application is illustrated by
a short example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;/* First include all needed cygwin stuff. */
#ifdef __CYGWIN__
#include &#60;windows.h&#62;
#include &#60;sys/cygwin.h&#62;
/* Use the following define to determine the Windows version */
#define is_winnt        (GetVersion() &#60; 0x80000000)
#endif

[...]

  struct passwd *user_pwd_entry = getpwnam (username);
  char *cleartext_password = getpass ("Password:");

[...]

#ifdef __CYGWIN__
  /* Patch the typical password test. */
  if (is_winnt)
    {
      HANDLE token;

      /* Try to get the access token from NT. */
      token = cygwin_logon_user (user_pwd_entry, cleartext_password);
      if (token == INVALID_HANDLE_VALUE)
         error_exit;
      /* Inform Cygwin about the new impersonation token.
         Cygwin is able now, to switch to that user context by
         setuid or seteuid calls. */
      cygwin_set_impersonation_token (token);
    }
  else
#endif /* CYGWIN */
    /* Use standard method for W9X as well. */
    hashed_password = crypt (cleartext_password, salt);
    if (!user_pwd_entry ||
        strcmp (hashed_password, user_pwd_entry-&#62;pw_password))
      error_exit;

[...]

  /* Everything else remains the same! */

  setegid (user_pwd_entry-&#62;pw_gid);
  seteuid (user_pwd_entry-&#62;pw_uid);
  execl ("/bin/sh", ...);&#13;</PRE
></TD
></TR
></TABLE
><P
>The new Cygwin call to retrive an access token is defined as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;windows.h&#62;
#include &#60;sys/cygwin.h&#62;

HANDLE
cygwin_logon_user (struct passwd *pw, const char *cleartext_password)</PRE
></TD
></TR
></TABLE
><P
>You can call that function as often as you want for different user
logons and remeber the access tokens for further calls to the second function.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;windows.h&#62;
#include &#60;sys/cygwin.h&#62;

void
cygwin_set_impersonation_token (HANDLE hToken);</PRE
></TD
></TR
></TABLE
><P
> is the call to inform Cygwin about the user context to which further
calls to <B
CLASS="COMMAND"
>setuid</B
>/<B
CLASS="COMMAND"
>seteuid</B
> should switch to.
While you need always the correct access token to do a
<B
CLASS="COMMAND"
>setuid</B
>/<B
CLASS="COMMAND"
>seteuid</B
> to another users context,
you are always able to use <B
CLASS="COMMAND"
>setuid</B
>/<B
CLASS="COMMAND"
>seteuid</B
>
to return to your own user context by giving your own uid as parameter.</P
><P
>If you have remembered several access tokens from calls to
<B
CLASS="COMMAND"
>cygwin_logon_user</B
> you can switch to different user
contexts by observing the following order:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;  cygwin_set_impersonation_token (user1_token);
  seteuid (user1_uid);

[...]

  seteuid (own_uid);
  cygwin_set_impersonation_token (user2_token);
  seteuid (user2_uid);

[...]

  seteuid (own_uid);
  cygwin_set_impersonation_token (user1_token);
  seteuid (user1_uid);

etc.&#13;</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="setup-env.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="cygwin-ug-net.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="setup-files.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Environment Variables</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="setup-net.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Customizing bash</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>